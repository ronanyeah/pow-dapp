/*! For license information please see worker.js.LICENSE.txt */
(()=>{var e={176:e=>{var t=Object.prototype.toString,n=Object.keys||function(e){var t=[];for(var n in e)t.push(n);return t};function r(e,o){var i,a,s,c,u,d,l;if(!0===e)return"true";if(!1===e)return"false";switch(typeof e){case"object":if(null===e)return null;if(e.toJSON&&"function"==typeof e.toJSON)return r(e.toJSON(),o);if("[object Array]"===(l=t.call(e))){for(s="[",a=e.length-1,i=0;i<a;i++)s+=r(e[i],!0)+",";return a>-1&&(s+=r(e[i],!0)),s+"]"}if("[object Object]"===l){for(a=(c=n(e).sort()).length,s="",i=0;i<a;)void 0!==(d=r(e[u=c[i]],!1))&&(s&&(s+=","),s+=JSON.stringify(u)+":"+d),i++;return"{"+s+"}"}return JSON.stringify(e);case"function":case"undefined":return o?null:void 0;case"string":return JSON.stringify(e);default:return isFinite(e)?e:null}}e.exports=function(e){var t=r(e,!1);if(void 0!==t)return""+t}},244:function(e,t,n){"use strict";var r=this&&this.__awaiter||function(e,t,n,r){return new(n||(n=Promise))((function(o,i){function a(e){try{c(r.next(e))}catch(e){i(e)}}function s(e){try{c(r.throw(e))}catch(e){i(e)}}function c(e){var t;e.done?o(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(a,s)}c((r=r.apply(e,t||[])).next())}))},o=this&&this.__generator||function(e,t){var n,r,o,i,a={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return i={next:s(0),throw:s(1),return:s(2)},"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function s(s){return function(c){return function(s){if(n)throw new TypeError("Generator is already executing.");for(;i&&(i=0,s[0]&&(a=0)),a;)try{if(n=1,r&&(o=2&s[0]?r.return:s[0]?r.throw||((o=r.return)&&o.call(r),0):r.next)&&!(o=o.call(r,s[1])).done)return o;switch(r=0,o&&(s=[2&s[0],o.value]),s[0]){case 0:case 1:o=s;break;case 4:return a.label++,{value:s[1],done:!1};case 5:a.label++,r=s[1],s=[0];continue;case 7:s=a.ops.pop(),a.trys.pop();continue;default:if(!((o=(o=a.trys).length>0&&o[o.length-1])||6!==s[0]&&2!==s[0])){a=0;continue}if(3===s[0]&&(!o||s[1]>o[0]&&s[1]<o[3])){a.label=s[1];break}if(6===s[0]&&a.label<o[1]){a.label=o[1],o=s;break}if(o&&a.label<o[2]){a.label=o[2],a.ops.push(s);break}o[2]&&a.ops.pop(),a.trys.pop();continue}s=t.call(e,a)}catch(e){s=[6,e],r=0}finally{n=o=0}if(5&s[0])throw s[1];return{value:s[0]?s[1]:void 0,done:!0}}([s,c])}}};Object.defineProperty(t,"__esModule",{value:!0}),n(744);var i=n(224);function a(e){return r(this,void 0,void 0,(function(){var t,n,r,i;return o(this,(function(o){switch(o.label){case 0:return[4,Promise.all([crypto.subtle.exportKey("raw",e.publicKey),crypto.subtle.exportKey("pkcs8",e.privateKey)])];case 1:return t=o.sent(),n=t[0],r=t[1],(i=new Uint8Array(64)).set(new Uint8Array(r).slice(16)),i.set(new Uint8Array(n),32),[2,i]}}))}))}onmessage=function(e){return r(void 0,void 0,void 0,(function(){var t,n,r,s,c,u,d,l,f,g,m;return o(this,(function(o){switch(o.label){case 0:t=e.data,n=function(){var e=t.criteria;if(e)return"start"in e&&"end"in e?function(t){return t.startsWith(e.start)&&t.endsWith(e.end)}:"start"in e?function(t){return t.startsWith(e.start)}:function(t){return t.endsWith(e.end)};var n=/^pow[1-9]\d*/;return function(e){return n.test(e)}}(),r=0,s=[],o.label=1;case 1:if(!(r<t.count))return[3,6];o.label=2;case 2:return o.trys.push([2,4,,5]),[4,crypto.subtle.generateKey("Ed25519",!0,["sign","verify"])];case 3:return l=o.sent(),s.push(l),[3,5];case 4:return c=o.sent(),console.error("Failed to generate keypair:",c),[3,5];case 5:return r+=1,[3,1];case 6:u=0,d=s,o.label=7;case 7:if(!(u<d.length))return[3,14];l=d[u],o.label=8;case 8:return o.trys.push([8,12,,13]),[4,(0,i.getAddressFromPublicKey)(l.publicKey)];case 9:return f=o.sent(),n(f)?[4,a(l)]:[3,11];case 10:g=o.sent(),self.postMessage({match:g}),o.label=11;case 11:return[3,13];case 12:return m=o.sent(),console.error("Failed to process keypair:",m),[3,13];case 13:return u++,[3,7];case 14:return self.postMessage({exit:r}),[2]}}))}))}},932:(e,t,n)=>{"use strict";var r=n(864);function o(e){return!("exists"in e)||"exists"in e&&e.exists}function i(e,t){if(!t)return Object.freeze({address:e,exists:!1});const n=r.getBase64Encoder().encode(t.data[0]);return Object.freeze({...s(t),address:e,data:n,exists:!0})}function a(e,t){if(!t)return Object.freeze({address:e,exists:!1});const n=t.data.parsed.info;return Object.freeze({...s(t),address:e,data:n,exists:!0})}function s(e){return Object.freeze({executable:e.executable,lamports:e.lamports,programAddress:e.owner})}t.BASE_ACCOUNT_SIZE=128,t.assertAccountDecoded=function(e){if(o(e)&&e.data instanceof Uint8Array)throw new Error(`Expected account [${e.address}] to be decoded.`)},t.assertAccountExists=function(e){if(!e.exists)throw new Error(`Expected account [${e.address}] to exist.`)},t.assertAccountsDecoded=function(e){const t=e.filter((e=>o(e)&&e.data instanceof Uint8Array));if(t.length>0){const e=t.map((e=>e.address)).join(", ");throw new Error(`Expected accounts [${e}] to be decoded.`)}},t.assertAccountsExist=function(e){const t=e.filter((e=>!e.exists));if(t.length>0){const e=t.map((e=>e.address));throw new Error(`Expected accounts [${e.join(", ")}] to exist.`)}},t.decodeAccount=function(e,t){try{return"exists"in e&&!e.exists?e:Object.freeze({...e,data:t.decode(e.data)})}catch(t){const n=new Error(`Failed to decode account [${e.address}].`);throw n.cause=t,n}},t.fetchEncodedAccount=async function(e,t,n={}){const{abortSignal:r,...o}=n;return i(t,(await e.getAccountInfo(t,{...o,encoding:"base64"}).send({abortSignal:r})).value)},t.fetchEncodedAccounts=async function(e,t,n={}){const{abortSignal:r,...o}=n;return(await e.getMultipleAccounts(t,{...o,encoding:"base64"}).send({abortSignal:r})).value.map(((e,n)=>i(t[n],e)))},t.fetchJsonParsedAccount=async function(e,t,n={}){const{abortSignal:r,...o}=n,{value:s}=await e.getAccountInfo(t,{...o,encoding:"jsonParsed"}).send({abortSignal:r});return s&&"object"==typeof s&&"parsed"in s.data?a(t,s):i(t,s)},t.fetchJsonParsedAccounts=async function(e,t,n={}){const{abortSignal:r,...o}=n;return(await e.getMultipleAccounts(t,{...o,encoding:"jsonParsed"}).send({abortSignal:r})).value.map(((e,n)=>e&&"object"==typeof e&&"parsed"in e.data?a(t[n],e):i(t[n],e)))},t.parseBase58RpcAccount=function(e,t){if(!t)return Object.freeze({address:e,exists:!1});const n=r.getBase58Encoder().encode("string"==typeof t.data?t.data:t.data[0]);return Object.freeze({...s(t),address:e,data:n,exists:!0})},t.parseBase64RpcAccount=i,t.parseJsonRpcAccount=a},868:(e,t,n)=>{"use strict";var r,o,i=n(112),a=n(864),s=n(220);function c(){return r||(r=a.getBase58Encoder()),r}function u(e){return!(e.length<32||e.length>44)&&32===c().encode(e).byteLength}function d(e){try{if(e.length<32||e.length>44)throw new Error("Expected input string to decode to a byte array of length 32.");const t=c().encode(e).byteLength;if(32!==t)throw new Error(`Expected input string to decode to a byte array of length 32. Actual length: ${t}`)}catch(t){throw new Error(`\`${e}\` is not a base-58 encoded address`,{cause:t})}}function l(e){return d(e),e}function f(){return i.mapEncoder(a.getStringEncoder({encoding:c(),size:32}),(e=>l(e)))}function g(){return a.getStringDecoder({encoding:(o||(o=a.getBase58Decoder()),o),size:32})}function m(){return i.combineCodec(f(),g())}var p=37095705934669439343138083508754565189542113879843219016388785533085940283555n,h=57896044618658097711785492504343953926634992332820282019728792003956564819949n,y=19681161376707505956807079304988542015446066515923890162744021073123829784752n;function b(e){const t=e%h;return t>=0n?t:h+t}function w(e,t){let n=e;for(;t-- >0n;)n*=n,n%=h;return n}async function S(e){if(32!==e.byteLength)return!1;const t=function(e){const t=e.reduce(((e,t,n)=>`${function(e){const t=e.toString(16);return 1===t.length?`0${t}`:t}(31===n?-129&t:t)}${e}`),"");return BigInt(`0x${t}`)}(e);return function(e,t){const n=b(e*e),r=function(e,t){const n=b(t*t*t),r=function(e){const t=e*e%h*e%h,n=w(t,2n)*t%h,r=w(n,1n)*e%h,o=w(r,5n)*r%h,i=w(o,10n)*o%h,a=w(i,20n)*i%h,s=w(a,40n)*a%h,c=w(s,80n)*s%h,u=w(c,80n)*s%h,d=w(u,10n)*o%h;return w(d,2n)*e%h}(e*b(n*n*t));let o=b(e*n*r);const i=b(t*o*o),a=o,s=b(o*y),c=i===e,u=i===b(-e),d=i===b(-e*y);return c&&(o=a),(u||d)&&(o=s),1n===(1n&b(o))&&(o=b(-o)),c||u?o:null}(b(n-1n),b(p*n+1n));return!(null===r||0n===r&&0!=(128&t))}(t,e[31])}var E=[80,114,111,103,114,97,109,68,101,114,105,118,101,100,65,100,100,114,101,115,115],A=class extends Error{};async function v({programAddress:e,seeds:t}){if(await s.assertDigestCapabilityIsAvailable(),t.length>16)throw new Error("A maximum of 16 seeds may be supplied when creating an address");let n;const r=t.reduce(((e,t,r)=>{const o="string"==typeof t?(n||=new TextEncoder).encode(t):t;if(o.byteLength>32)throw new Error(`The seed at index ${r} exceeds the maximum length of 32 bytes`);return e.push(...o),e}),[]),o=m(),i=o.encode(e),a=await crypto.subtle.digest("SHA-256",new Uint8Array([...r,...i,...E])),c=new Uint8Array(a);if(await S(c))throw new A("Invalid seeds; point must fall off the Ed25519 curve");return o.decode(c)}t.address=l,t.assertIsAddress=d,t.assertIsProgramDerivedAddress=function(e){if(!Array.isArray(e)||2!==e.length||"string"!=typeof e[0]||"number"!=typeof e[1])throw new Error("Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].");if(e[1]<0||e[1]>255)throw new Error(`Expected program derived address bump to be in the range [0, 255], got: ${e[1]}.`);d(e[0])},t.createAddressWithSeed=async function({baseAddress:e,programAddress:t,seed:n}){const{encode:r,decode:o}=m(),i="string"==typeof n?(new TextEncoder).encode(n):n;if(i.byteLength>32)throw new Error("The seed exceeds the maximum length of 32 bytes");const a=r(t);if(a.length>=E.length&&a.slice(-E.length).every(((e,t)=>e===E[t])))throw new Error("programAddress cannot end with the PDA marker");const s=await crypto.subtle.digest("SHA-256",new Uint8Array([...r(e),...i,...a]));return o(new Uint8Array(s))},t.getAddressCodec=m,t.getAddressComparator=function(){return new Intl.Collator("en",{caseFirst:"lower",ignorePunctuation:!1,localeMatcher:"best fit",numeric:!1,sensitivity:"variant",usage:"sort"}).compare},t.getAddressDecoder=g,t.getAddressEncoder=f,t.getAddressFromPublicKey=async function(e){if(await s.assertKeyExporterIsAvailable(),"public"!==e.type||"Ed25519"!==e.algorithm.name)throw new Error("The `CryptoKey` must be an `Ed25519` public key");const t=await crypto.subtle.exportKey("raw",e);return g().decode(new Uint8Array(t))},t.getProgramDerivedAddress=async function({programAddress:e,seeds:t}){let n=255;for(;n>0;)try{return[await v({programAddress:e,seeds:[...t,new Uint8Array([n])]}),n]}catch(e){if(!(e instanceof A))throw e;n--}throw new Error("Unable to find a viable program address bump seed")},t.isAddress=u,t.isProgramDerivedAddress=function(e){return Array.isArray(e)&&2===e.length&&"string"==typeof e[0]&&"number"==typeof e[1]&&e[1]>=0&&e[1]<=255&&u(e[0])}},220:(e,t)=>{"use strict";function n(){if(!globalThis.isSecureContext)throw new Error("Cryptographic operations are only allowed in secure browser contexts. Read more here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts")}var r;t.assertDigestCapabilityIsAvailable=async function(){if(n(),void 0===globalThis.crypto||"function"!=typeof globalThis.crypto.subtle?.digest)throw new Error("No digest implementation could be found")},t.assertKeyExporterIsAvailable=async function(){if(n(),void 0===globalThis.crypto||"function"!=typeof globalThis.crypto.subtle?.exportKey)throw new Error("No key export implementation could be found")},t.assertKeyGenerationIsAvailable=async function(){if(n(),void 0===globalThis.crypto||"function"!=typeof globalThis.crypto.subtle?.generateKey)throw new Error("No key generation implementation could be found");if(!await async function(e){return void 0===r&&(r=new Promise((t=>{e.generateKey("Ed25519",!1,["sign","verify"]).catch((()=>{t(r=!1)})).then((()=>{t(r=!0)}))}))),"boolean"==typeof r?r:await r}(globalThis.crypto.subtle))throw new Error("This runtime does not support the generation of Ed25519 key pairs.\n\nInstall and import `@solana/webcrypto-ed25519-polyfill` before generating keys in environments that do not support Ed25519.\n\nFor a list of runtimes that currently support Ed25519 operations, visit https://github.com/WICG/webcrypto-secure-curves/issues/20")},t.assertSigningCapabilityIsAvailable=async function(){if(n(),void 0===globalThis.crypto||"function"!=typeof globalThis.crypto.subtle?.sign)throw new Error("No signing implementation could be found")},t.assertVerificationCapabilityIsAvailable=async function(){if(n(),void 0===globalThis.crypto||"function"!=typeof globalThis.crypto.subtle?.verify)throw new Error("No signature verification implementation could be found")}},112:(e,t)=>{"use strict";function n(e,t,n,r=0){const o=n.length-r;if(o<t)throw new Error(`Codec [${e}] expected ${t} bytes, got ${o}.`)}var r=(e,t)=>{if(e.length>=t)return e;const n=new Uint8Array(t).fill(0);return n.set(e),n},o=(e,t)=>r(e.length<=t?e:e.slice(0,t),t);function i(e,t){return"fixedSize"in t?t.fixedSize:t.getSizeFromValue(e)}function a(e){return Object.freeze({...e,encode:t=>{const n=new Uint8Array(i(t,e));return e.write(t,n,0),n}})}function s(e){return Object.freeze({...e,decode:(t,n=0)=>e.read(t,n)[0]})}function c(e){return Object.freeze({...e,decode:(t,n=0)=>e.read(t,n)[0],encode:t=>{const n=new Uint8Array(i(t,e));return e.write(t,n,0),n}})}function u(e){return"fixedSize"in e&&"number"==typeof e.fixedSize}function d(e,t){if(!u(e))throw new Error(t??"Expected a fixed-size codec, got a variable-size one.")}function l(e){return!u(e)}function f(e,t){if(u(e)!==u(t))throw new Error("Encoder and decoder must either both be fixed-size or variable-size.");if(u(e)&&u(t)&&e.fixedSize!==t.fixedSize)throw new Error(`Encoder and decoder must have the same fixed size, got [${e.fixedSize}] and [${t.fixedSize}].`);if(!u(e)&&!u(t)&&e.maxSize!==t.maxSize)throw new Error(`Encoder and decoder must have the same max size, got [${e.maxSize}] and [${t.maxSize}].`);return{...t,...e,decode:t.decode,encode:e.encode,read:t.read,write:e.write}}function g(e,t){return a({fixedSize:t,write:(n,r,o)=>{const i=e.encode(n),a=i.length>t?i.slice(0,t):i;return r.set(a,o),o+t}})}function m(e,t){return s({fixedSize:t,read:(r,i)=>{n("fixCodec",t,r,i),(i>0||r.length>t)&&(r=r.slice(i,i+t)),u(e)&&(r=o(r,e.fixedSize));const[a]=e.read(r,0);return[a,i+t]}})}function p(e,t){return a({...l(e)?{...e,getSizeFromValue:n=>e.getSizeFromValue(t(n))}:e,write:(n,r,o)=>e.write(t(n),r,o)})}function h(e,t){return s({...e,read:(n,r)=>{const[o,i]=e.read(n,r);return[t(o,n,r),i]}})}function y(e){return d(e,"Cannot reverse a codec of variable size."),a({...e,write:(t,n,r)=>{const o=e.write(t,n,r),i=n.slice(r,r+e.fixedSize).reverse();return n.set(i,r),o}})}function b(e){return d(e,"Cannot reverse a codec of variable size."),s({...e,read:(t,n)=>{const r=n+e.fixedSize;if(0===n&&t.length===r)return e.read(t.reverse(),n);const o=t.slice();return o.set(t.slice(n,r).reverse(),n),e.read(o,n)}})}t.assertByteArrayHasEnoughBytesForCodec=n,t.assertByteArrayIsNotEmptyForCodec=function(e,t,n=0){if(t.length-n<=0)throw new Error(`Codec [${e}] cannot decode empty byte arrays.`)},t.assertIsFixedSize=d,t.assertIsVariableSize=function(e,t){if(!l(e))throw new Error(t??"Expected a variable-size codec, got a fixed-size one.")},t.combineCodec=f,t.createCodec=c,t.createDecoder=s,t.createEncoder=a,t.fixBytes=o,t.fixCodec=function(e,t){return f(g(e,t),m(e,t))},t.fixDecoder=m,t.fixEncoder=g,t.getEncodedSize=i,t.isFixedSize=u,t.isVariableSize=l,t.mapCodec=function(e,t,n){return c({...p(e,t),read:n?h(e,n).read:e.read})},t.mapDecoder=h,t.mapEncoder=p,t.mergeBytes=e=>{const t=e.filter((e=>e.length));if(0===t.length)return e.length?e[0]:new Uint8Array;if(1===t.length)return t[0];const n=t.reduce(((e,t)=>e+t.length),0),r=new Uint8Array(n);let o=0;return t.forEach((e=>{r.set(e,o),o+=e.length})),r},t.padBytes=r,t.reverseCodec=function(e){return f(y(e),b(e))},t.reverseDecoder=b,t.reverseEncoder=y},848:(e,t,n)=>{"use strict";var r=n(112),o=n(660);function i(e,t,n){if(t!==n)throw new Error(`Expected [${e}] to have ${t} items, got ${n}.`)}function a(e){return e.reduce(((e,t)=>null===e||null===t?null:e+t),0)}function s(e){return r.isFixedSize(e)?e.fixedSize:null}function c(e){return r.isFixedSize(e)?e.fixedSize:e.maxSize??null}function u(e,t={}){const n=t.size??o.getU32Encoder(),a=l(n,s(e)),u=l(n,c(e))??void 0;return r.createEncoder({...null!==a?{fixedSize:a}:{getSizeFromValue:t=>("object"==typeof n?r.getEncodedSize(t.length,n):0)+[...t].reduce(((t,n)=>t+r.getEncodedSize(n,e)),0),maxSize:u},write:(t,r,o)=>("number"==typeof n&&i("array",n,t.length),"object"==typeof n&&(o=n.write(t.length,r,o)),t.forEach((t=>{o=e.write(t,r,o)})),o)})}function d(e,t={}){const n=t.size??o.getU32Decoder(),i=s(e),a=l(n,i),u=l(n,c(e))??void 0;return r.createDecoder({...null!==a?{fixedSize:a}:{maxSize:u},read:(t,r)=>{const o=[];if("object"==typeof n&&0===t.slice(r).length)return[o,r];if("remainder"===n){for(;r<t.length;){const[n,i]=e.read(t,r);r=i,o.push(n)}return[o,r]}const[i,a]="number"==typeof n?[n,r]:n.read(t,r);r=a;for(let n=0;n<i;n+=1){const[n,i]=e.read(t,r);r=i,o.push(n)}return[o,r]}})}function l(e,t){return"number"!=typeof e?null:0===e?0:null===t?null:t*e}function f(e,t={}){const n=("boolean"==typeof t?{backward:t}:t).backward??!1;return r.createEncoder({fixedSize:e,write(t,r,o){const i=[];for(let r=0;r<e;r+=1){let e=0;for(let o=0;o<8;o+=1)e|=Number(t[8*r+o]??0)<<(n?o:7-o);n?i.unshift(e):i.push(e)}return r.set(i,o),e}})}function g(e,t={}){const n=("boolean"==typeof t?{backward:t}:t).backward??!1;return r.createDecoder({fixedSize:e,read(t,o){r.assertByteArrayHasEnoughBytesForCodec("bitArray",e,t,o);const i=[];let a=t.slice(o,o+e);return a=n?a.reverse():a,a.forEach((e=>{for(let t=0;t<8;t+=1)n?(i.push(Boolean(1&e)),e>>=1):(i.push(Boolean(128&e)),e<<=1)})),[i,o+e]}})}function m(e={}){const t=e.size??o.getU8Encoder();return r.assertIsFixedSize(t,"Codec [bool] requires a fixed size."),r.mapEncoder(t,(e=>e?1:0))}function p(e={}){const t=e.size??o.getU8Decoder();return r.assertIsFixedSize(t,"Codec [bool] requires a fixed size."),r.mapDecoder(t,(e=>1===Number(e)))}function h(e={}){const t=e.size??"variable",n=r.createEncoder({getSizeFromValue:e=>e.length,write:(e,t,n)=>(t.set(e,n),n+e.length)});return"variable"===t?n:"number"==typeof t?r.fixEncoder(n,t):r.createEncoder({getSizeFromValue:e=>r.getEncodedSize(e.length,t)+e.length,write:(e,r,o)=>(o=t.write(e.length,r,o),n.write(e,r,o))})}function y(e={}){const t=e.size??"variable",n=r.createDecoder({read:(e,t)=>{const n=e.slice(t);return[n,t+n.length]}});return"variable"===t?n:"number"==typeof t?r.fixDecoder(n,t):r.createDecoder({read:(e,o)=>{r.assertByteArrayIsNotEmptyForCodec("bytes",e,o);const[i,a]=t.read(e,o),s=Number(i);o=a;const c=e.slice(o,o+s);r.assertByteArrayHasEnoughBytesForCodec("bytes",s,c);const[u,d]=n.read(c,0);return[u,o+=d]}})}function b(e,t={}){const n=t.size??o.getU8Encoder(),i=S(e,n);return r.createEncoder({...null!==i?{fixedSize:i}:{getSizeFromValue:t=>{const o=A(e,t),i=e[o][1];return r.getEncodedSize(o,n)+r.getEncodedSize(t,i)},maxSize:E(e,n)},write:(t,r,o)=>{const i=A(e,t);return o=n.write(i,r,o),e[i][1].write(t,r,o)}})}function w(e,t={}){const n=t.size??o.getU8Decoder(),i=S(e,n);return r.createDecoder({...null!==i?{fixedSize:i}:{maxSize:E(e,n)},read:(t,o)=>{r.assertByteArrayIsNotEmptyForCodec("dataEnum",t,o);const[i,a]=n.read(t,o);o=a;const s=e[Number(i)]??null;if(!s)throw new Error(`Enum discriminator out of range. Expected a number between 0 and ${e.length-1}, got ${i}.`);const[c,u]=s[1].read(t,o);return o=u,[{__kind:s[0],...c??{}},o]}})}function S(e,t){if(0===e.length)return r.isFixedSize(t)?t.fixedSize:null;if(!r.isFixedSize(e[0][1]))return null;const n=e[0][1].fixedSize;return e.every((e=>r.isFixedSize(e[1])&&e[1].fixedSize===n))&&r.isFixedSize(t)?t.fixedSize+n:null}function E(e,t){const n=e.map((([,e])=>c(e))).reduce(((e,t)=>null===e||null===t?null:Math.max(e,t)),0);return a([c(t),n])??void 0}function A(e,t){const n=e.findIndex((([e])=>t.__kind===e));if(n<0)throw new Error(`Invalid data enum variant. Expected one of [${e.map((([e])=>e)).join(", ")}], got "${t.__kind}".`);return n}function v(e){const t=a(e.map(s)),n=a(e.map(c))??void 0;return r.createEncoder({...null===t?{getSizeFromValue:t=>e.map(((e,n)=>r.getEncodedSize(t[n],e))).reduce(((e,t)=>e+t),0),maxSize:n}:{fixedSize:t},write:(t,n,r)=>(i("tuple",e.length,t.length),e.forEach(((e,o)=>{r=e.write(t[o],n,r)})),r)})}function x(e){const t=a(e.map(s)),n=a(e.map(c))??void 0;return r.createDecoder({...null===t?{maxSize:n}:{fixedSize:t},read:(t,n)=>{const r=[];return e.forEach((e=>{const[o,i]=e.read(t,n);r.push(o),n=i})),[r,n]}})}function T(e,t,n={}){return r.mapEncoder(u(v([e,t]),n),(e=>[...e.entries()]))}function I(e,t,n={}){return r.mapDecoder(d(x([e,t]),n),(e=>new Map(e)))}function k(e,t={}){const n=t.prefix??o.getU8Encoder(),i=t.fixed??!1,s=r.isFixedSize(e)&&r.isFixedSize(n)&&0===e.fixedSize;if(i||s){r.assertIsFixedSize(e,"Fixed nullables can only be used with fixed-size codecs."),r.assertIsFixedSize(n,"Fixed nullables can only be used with fixed-size prefix.");const t=n.fixedSize+e.fixedSize;return r.createEncoder({fixedSize:t,write:(r,o,i)=>{const a=n.write(Number(null!==r),o,i);return null!==r&&e.write(r,o,a),i+t}})}return r.createEncoder({getSizeFromValue:t=>r.getEncodedSize(Number(null!==t),n)+(null!==t?r.getEncodedSize(t,e):0),maxSize:a([n,e].map(c))??void 0,write:(t,r,o)=>(o=n.write(Number(null!==t),r,o),null!==t&&(o=e.write(t,r,o)),o)})}function z(e,t={}){const n=t.prefix??o.getU8Decoder(),i=t.fixed??!1;let s=null;const u=r.isFixedSize(e)&&r.isFixedSize(n)&&0===e.fixedSize;return(i||u)&&(r.assertIsFixedSize(e,"Fixed nullables can only be used with fixed-size codecs."),r.assertIsFixedSize(n,"Fixed nullables can only be used with fixed-size prefix."),s=n.fixedSize+e.fixedSize),r.createDecoder({...null===s?{maxSize:a([n,e].map(c))??void 0}:{fixedSize:s},read:(t,r)=>{if(t.length-r<=0)return[null,r];const[o,i]=n.read(t,r);if(0===o)return[null,null!==s?r+s:i];const[a,c]=e.read(t,i);return[a,null!==s?r+s:c]}})}function C(e,t={}){const n=t.size??o.getU8Encoder(),{minRange:i,maxRange:a,stringValues:s,enumKeys:c,enumValues:u}=B(e);return r.mapEncoder(n,(e=>{const t="number"==typeof e&&(e<i||e>a),n="string"==typeof e&&!s.includes(e);if(t||n)throw new Error(`Invalid scalar enum variant. Expected one of [${s.join(", ")}] or a number between ${i} and ${a}, got "${e}".`);if("number"==typeof e)return e;const r=u.indexOf(e);return r>=0?r:c.indexOf(e)}))}function O(e,t={}){const n=t.size??o.getU8Decoder(),{minRange:i,maxRange:a,isNumericEnum:s,enumValues:c}=B(e);return r.mapDecoder(n,(e=>{const t=Number(e);if(t<i||t>a)throw new Error(`Enum discriminator out of range. Expected a number between ${i} and ${a}, got ${t}.`);return s?t:c[t]}))}function B(e){const t=Object.keys(e),n=Object.values(e),r=n.some((e=>"number"==typeof e));return{enumKeys:t,enumValues:n,isNumericEnum:r,maxRange:r?n.length/2-1:n.length-1,minRange:0,stringValues:r?[...t]:[...new Set([...t,...n])]}}function N(e,t={}){return r.mapEncoder(u(e,t),(e=>[...e]))}function D(e,t={}){return r.mapDecoder(d(e,t),(e=>new Set(e)))}function R(e){const t=e.map((([,e])=>e)),n=a(t.map(s)),o=a(t.map(c))??void 0;return r.createEncoder({...null===n?{getSizeFromValue:t=>e.map((([e,n])=>r.getEncodedSize(t[e],n))).reduce(((e,t)=>e+t),0),maxSize:o}:{fixedSize:n},write:(t,n,r)=>(e.forEach((([e,o])=>{r=o.write(t[e],n,r)})),r)})}function P(e){const t=e.map((([,e])=>e)),n=a(t.map(s)),o=a(t.map(c))??void 0;return r.createDecoder({...null===n?{maxSize:o}:{fixedSize:n},read:(t,n)=>{const r={};return e.forEach((([e,o])=>{const[i,a]=o.read(t,n);n=a,r[e]=i})),[r,n]}})}function _(){return r.createEncoder({fixedSize:0,write:(e,t,n)=>n})}function U(){return r.createDecoder({fixedSize:0,read:(e,t)=>[void 0,t]})}t.assertValidNumberOfItemsForCodec=i,t.getArrayCodec=function(e,t={}){return r.combineCodec(u(e,t),d(e,t))},t.getArrayDecoder=d,t.getArrayEncoder=u,t.getBitArrayCodec=function(e,t={}){return r.combineCodec(f(e,t),g(e,t))},t.getBitArrayDecoder=g,t.getBitArrayEncoder=f,t.getBooleanCodec=function(e={}){return r.combineCodec(m(e),p(e))},t.getBooleanDecoder=p,t.getBooleanEncoder=m,t.getBytesCodec=function(e={}){return r.combineCodec(h(e),y(e))},t.getBytesDecoder=y,t.getBytesEncoder=h,t.getDataEnumCodec=function(e,t={}){return r.combineCodec(b(e,t),w(e,t))},t.getDataEnumDecoder=w,t.getDataEnumEncoder=b,t.getMapCodec=function(e,t,n={}){return r.combineCodec(T(e,t,n),I(e,t,n))},t.getMapDecoder=I,t.getMapEncoder=T,t.getNullableCodec=function(e,t={}){const n=t;return r.combineCodec(k(e,n),z(e,n))},t.getNullableDecoder=z,t.getNullableEncoder=k,t.getScalarEnumCodec=function(e,t={}){return r.combineCodec(C(e,t),O(e,t))},t.getScalarEnumDecoder=O,t.getScalarEnumEncoder=C,t.getSetCodec=function(e,t={}){return r.combineCodec(N(e,t),D(e,t))},t.getSetDecoder=D,t.getSetEncoder=N,t.getStructCodec=function(e){return r.combineCodec(R(e),P(e))},t.getStructDecoder=P,t.getStructEncoder=R,t.getTupleCodec=function(e){return r.combineCodec(v(e),x(e))},t.getTupleDecoder=x,t.getTupleEncoder=v,t.getUnitCodec=function(){return r.combineCodec(_(),U())},t.getUnitDecoder=U,t.getUnitEncoder=_},660:(e,t,n)=>{"use strict";var r=n(112);function o(e,t,n,r){if(r<t||r>n)throw new Error(`Codec [${e}] expected number to be in the range [${t}, ${n}], got ${r}.`)}var i=(e=>(e[e.LITTLE=0]="LITTLE",e[e.BIG=1]="BIG",e))(i||{});function a(e){return 1!==e?.endian}function s(e){return r.createEncoder({fixedSize:e.size,write(t,n,r){e.range&&o(e.name,e.range[0],e.range[1],t);const i=new ArrayBuffer(e.size);return e.set(new DataView(i),t,a(e.config)),n.set(new Uint8Array(i),r),r+e.size}})}function c(e){return r.createDecoder({fixedSize:e.size,read(t,n=0){r.assertByteArrayIsNotEmptyForCodec(e.name,t,n),r.assertByteArrayHasEnoughBytesForCodec(e.name,e.size,t,n);const o=new DataView(function(e,t,n){const r=e.byteOffset+(t??0),o=n??e.byteLength;return e.buffer.slice(r,r+o)}(t,n,e.size));return[e.get(o,a(e.config)),n+e.size]}})}var u=(e={})=>s({config:e,name:"f32",set:(e,t,n)=>e.setFloat32(0,t,n),size:4}),d=(e={})=>c({config:e,get:(e,t)=>e.getFloat32(0,t),name:"f32",size:4}),l=(e={})=>s({config:e,name:"f64",set:(e,t,n)=>e.setFloat64(0,t,n),size:8}),f=(e={})=>c({config:e,get:(e,t)=>e.getFloat64(0,t),name:"f64",size:8}),g=(e={})=>s({config:e,name:"i128",range:[-BigInt("0x7fffffffffffffffffffffffffffffff")-1n,BigInt("0x7fffffffffffffffffffffffffffffff")],set:(e,t,n)=>{const r=n?8:0,o=n?0:8;e.setBigInt64(r,BigInt(t)>>64n,n),e.setBigUint64(o,0xffffffffffffffffn&BigInt(t),n)},size:16}),m=(e={})=>c({config:e,get:(e,t)=>{const n=t?8:0,r=t?0:8;return(e.getBigInt64(n,t)<<64n)+e.getBigUint64(r,t)},name:"i128",size:16}),p=(e={})=>s({config:e,name:"i16",range:[-Number("0x7fff")-1,Number("0x7fff")],set:(e,t,n)=>e.setInt16(0,t,n),size:2}),h=(e={})=>c({config:e,get:(e,t)=>e.getInt16(0,t),name:"i16",size:2}),y=(e={})=>s({config:e,name:"i32",range:[-Number("0x7fffffff")-1,Number("0x7fffffff")],set:(e,t,n)=>e.setInt32(0,t,n),size:4}),b=(e={})=>c({config:e,get:(e,t)=>e.getInt32(0,t),name:"i32",size:4}),w=(e={})=>s({config:e,name:"i64",range:[-BigInt("0x7fffffffffffffff")-1n,BigInt("0x7fffffffffffffff")],set:(e,t,n)=>e.setBigInt64(0,BigInt(t),n),size:8}),S=(e={})=>c({config:e,get:(e,t)=>e.getBigInt64(0,t),name:"i64",size:8}),E=()=>s({name:"i8",range:[-Number("0x7f")-1,Number("0x7f")],set:(e,t)=>e.setInt8(0,t),size:1}),A=()=>c({get:e=>e.getInt8(0),name:"i8",size:1}),v=()=>r.createEncoder({getSizeFromValue:e=>e<=127?1:e<=16383?2:3,maxSize:3,write:(e,t,n)=>{o("shortU16",0,65535,e);const r=[0];for(let t=0;;t+=1){const n=e>>7*t;if(0===n)break;const o=127&n;r[t]=o,t>0&&(r[t-1]|=128)}return t.set(r,n),n+r.length}}),x=()=>r.createDecoder({maxSize:3,read:(e,t)=>{let n=0,r=0;for(;++r;){const o=r-1,i=e[t+o];if(n|=(127&i)<<7*o,0==(128&i))break}return[n,t+r]}}),T=(e={})=>s({config:e,name:"u128",range:[0,BigInt("0xffffffffffffffffffffffffffffffff")],set:(e,t,n)=>{const r=n?8:0,o=n?0:8;e.setBigUint64(r,BigInt(t)>>64n,n),e.setBigUint64(o,0xffffffffffffffffn&BigInt(t),n)},size:16}),I=(e={})=>c({config:e,get:(e,t)=>{const n=t?8:0,r=t?0:8;return(e.getBigUint64(n,t)<<64n)+e.getBigUint64(r,t)},name:"u128",size:16}),k=(e={})=>s({config:e,name:"u16",range:[0,Number("0xffff")],set:(e,t,n)=>e.setUint16(0,t,n),size:2}),z=(e={})=>c({config:e,get:(e,t)=>e.getUint16(0,t),name:"u16",size:2}),C=(e={})=>s({config:e,name:"u32",range:[0,Number("0xffffffff")],set:(e,t,n)=>e.setUint32(0,t,n),size:4}),O=(e={})=>c({config:e,get:(e,t)=>e.getUint32(0,t),name:"u32",size:4}),B=(e={})=>s({config:e,name:"u64",range:[0,BigInt("0xffffffffffffffff")],set:(e,t,n)=>e.setBigUint64(0,BigInt(t),n),size:8}),N=(e={})=>c({config:e,get:(e,t)=>e.getBigUint64(0,t),name:"u64",size:8}),D=()=>s({name:"u8",range:[0,Number("0xff")],set:(e,t)=>e.setUint8(0,t),size:1}),R=()=>c({get:e=>e.getUint8(0),name:"u8",size:1});t.Endian=i,t.assertNumberIsBetweenForCodec=o,t.getF32Codec=(e={})=>r.combineCodec(u(e),d(e)),t.getF32Decoder=d,t.getF32Encoder=u,t.getF64Codec=(e={})=>r.combineCodec(l(e),f(e)),t.getF64Decoder=f,t.getF64Encoder=l,t.getI128Codec=(e={})=>r.combineCodec(g(e),m(e)),t.getI128Decoder=m,t.getI128Encoder=g,t.getI16Codec=(e={})=>r.combineCodec(p(e),h(e)),t.getI16Decoder=h,t.getI16Encoder=p,t.getI32Codec=(e={})=>r.combineCodec(y(e),b(e)),t.getI32Decoder=b,t.getI32Encoder=y,t.getI64Codec=(e={})=>r.combineCodec(w(e),S(e)),t.getI64Decoder=S,t.getI64Encoder=w,t.getI8Codec=()=>r.combineCodec(E(),A()),t.getI8Decoder=A,t.getI8Encoder=E,t.getShortU16Codec=()=>r.combineCodec(v(),x()),t.getShortU16Decoder=x,t.getShortU16Encoder=v,t.getU128Codec=(e={})=>r.combineCodec(T(e),I(e)),t.getU128Decoder=I,t.getU128Encoder=T,t.getU16Codec=(e={})=>r.combineCodec(k(e),z(e)),t.getU16Decoder=z,t.getU16Encoder=k,t.getU32Codec=(e={})=>r.combineCodec(C(e),O(e)),t.getU32Decoder=O,t.getU32Encoder=C,t.getU64Codec=(e={})=>r.combineCodec(B(e),N(e)),t.getU64Decoder=N,t.getU64Encoder=B,t.getU8Codec=()=>r.combineCodec(D(),R()),t.getU8Decoder=R,t.getU8Encoder=D},864:(e,t,n)=>{"use strict";var r=n(112),o=n(660);function i(e,t,n=t){if(!t.match(new RegExp(`^[${e}]*$`)))throw new Error(`Expected a string of base ${e.length}, got [${n}].`)}var a=e=>r.createEncoder({getSizeFromValue:t=>{const[n,r]=u(t,e[0]);if(""===r)return t.length;const o=d(r,e);return n.length+Math.ceil(o.toString(16).length/2)},write(t,n,r){if(i(e,t),""===t)return r;const[o,a]=u(t,e[0]);if(""===a)return n.set(new Uint8Array(o.length).fill(0),r),r+o.length;let s=d(a,e);const c=[];for(;s>0n;)c.unshift(Number(s%256n)),s/=256n;const l=[...Array(o.length).fill(0),...c];return n.set(l,r),r+l.length}}),s=e=>r.createDecoder({read(t,n){const r=0===n?t:t.slice(n);if(0===r.length)return["",0];let o=r.findIndex((e=>0!==e));o=-1===o?r.length:o;const i=e[0].repeat(o);if(o===r.length)return[i,t.length];const a=function(e,t){const n=BigInt(t.length),r=[];for(;e>0n;)r.unshift(t[Number(e%n)]),e/=n;return r.join("")}(r.slice(o).reduce(((e,t)=>256n*e+BigInt(t)),0n),e);return[i+a,t.length]}}),c=e=>r.combineCodec(a(e),s(e));function u(e,t){const n=[...e].findIndex((e=>e!==t));return-1===n?[e,""]:[e.slice(0,n),e.slice(n)]}function d(e,t){const n=BigInt(t.length);return[...e].reduce(((e,r)=>e*n+BigInt(t.indexOf(r))),0n)}var l="0123456789",f=()=>r.createEncoder({getSizeFromValue:e=>Math.ceil(e.length/2),write(e,t,n){const r=e.toLowerCase();i("0123456789abcdef",r,e);const o=r.match(/.{1,2}/g),a=o?o.map((e=>parseInt(e,16))):[];return t.set(a,n),a.length+n}}),g=()=>r.createDecoder({read:(e,t)=>[e.slice(t).reduce(((e,t)=>e+t.toString(16).padStart(2,"0")),""),e.length]}),m="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",p=(e,t)=>r.createEncoder({getSizeFromValue:e=>Math.floor(e.length*t/8),write(n,r,o){if(i(e,n),""===n)return o;const a=y([...n].map((t=>e.indexOf(t))),t,8,!1);return r.set(a,o),a.length+o}}),h=(e,t)=>r.createDecoder({read(n,r=0){const o=0===r?n:n.slice(r);return 0===o.length?["",n.length]:[y([...o],8,t,!0).map((t=>e[t])).join(""),n.length]}});function y(e,t,n,r){const o=[];let i=0,a=0;const s=(1<<n)-1;for(const r of e)for(i=i<<t|r,a+=t;a>=n;)a-=n,o.push(i>>a&s);return r&&a>0&&o.push(i<<n-a&s),o}var b=()=>r.createEncoder({getSizeFromValue:e=>{try{return atob(e).length}catch(t){throw new Error(`Expected a string of base 64, got [${e}].`)}},write(e,t,n){try{const r=atob(e).split("").map((e=>e.charCodeAt(0)));return t.set(r,n),r.length+n}catch(t){throw new Error(`Expected a string of base 64, got [${e}].`)}}}),w=()=>r.createDecoder({read(e,t=0){const n=e.slice(t);return[btoa(String.fromCharCode(...n)),e.length]}}),S=e=>e.replace(/\u0000/g,""),E=globalThis.TextDecoder,A=globalThis.TextEncoder,v=()=>{let e;return r.createEncoder({getSizeFromValue:t=>(e||=new A).encode(t).length,write:(t,n,r)=>{const o=(e||=new A).encode(t);return n.set(o,r),r+o.length}})},x=()=>{let e;return r.createDecoder({read(t,n){const r=(e||=new E).decode(t.slice(n));return[S(r),t.length]}})};function T(e={}){const t=e.size??o.getU32Encoder(),n=e.encoding??v();return"variable"===t?n:"number"==typeof t?r.fixEncoder(n,t):r.createEncoder({getSizeFromValue:e=>{const o=r.getEncodedSize(e,n);return r.getEncodedSize(o,t)+o},write:(e,o,i)=>{const a=r.getEncodedSize(e,n);return i=t.write(a,o,i),n.write(e,o,i)}})}function I(e={}){const t=e.size??o.getU32Decoder(),n=e.encoding??x();return"variable"===t?n:"number"==typeof t?r.fixDecoder(n,t):r.createDecoder({read:(e,o=0)=>{r.assertByteArrayIsNotEmptyForCodec("string",e,o);const[i,a]=t.read(e,o),s=Number(i);o=a;const c=e.slice(o,o+s);r.assertByteArrayHasEnoughBytesForCodec("string",s,c);const[u,d]=n.read(c,0);return[u,o+=d]}})}t.assertValidBaseString=i,t.getBase10Codec=()=>c(l),t.getBase10Decoder=()=>s(l),t.getBase10Encoder=()=>a(l),t.getBase16Codec=()=>r.combineCodec(f(),g()),t.getBase16Decoder=g,t.getBase16Encoder=f,t.getBase58Codec=()=>c(m),t.getBase58Decoder=()=>s(m),t.getBase58Encoder=()=>a(m),t.getBase64Codec=()=>r.combineCodec(b(),w()),t.getBase64Decoder=w,t.getBase64Encoder=b,t.getBaseXCodec=c,t.getBaseXDecoder=s,t.getBaseXEncoder=a,t.getBaseXResliceCodec=(e,t)=>r.combineCodec(p(e,t),h(e,t)),t.getBaseXResliceDecoder=h,t.getBaseXResliceEncoder=p,t.getStringCodec=function(e={}){return r.combineCodec(T(e),I(e))},t.getStringDecoder=I,t.getStringEncoder=T,t.getUtf8Codec=()=>r.combineCodec(v(),x()),t.getUtf8Decoder=x,t.getUtf8Encoder=v,t.padNullCharacters=(e,t)=>e.padEnd(t,"\0"),t.removeNullCharacters=S},480:(e,t,n)=>{"use strict";var r=n(112),o=n(848),i=n(660),a=n(864),s=n(272);Object.keys(r).forEach((function(e){"default"===e||Object.prototype.hasOwnProperty.call(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:function(){return r[e]}})})),Object.keys(o).forEach((function(e){"default"===e||Object.prototype.hasOwnProperty.call(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:function(){return o[e]}})})),Object.keys(i).forEach((function(e){"default"===e||Object.prototype.hasOwnProperty.call(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:function(){return i[e]}})})),Object.keys(a).forEach((function(e){"default"===e||Object.prototype.hasOwnProperty.call(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:function(){return a[e]}})})),Object.keys(s).forEach((function(e){"default"===e||Object.prototype.hasOwnProperty.call(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:function(){return s[e]}})}))},916:(e,t)=>{"use strict";var n=(()=>!1)(),r={3:"The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was `$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds `Number.MAX_SAFE_INTEGER`",1:"Transaction is missing signatures for addresses: $addresses",2:"Could not determine this transaction's signature. Make sure that the transaction has been signed by its fee payer."};function o(e){return Array.isArray(e)?"%5B"+e.map((e=>"string"==typeof e?encodeURIComponent(`"${e.replace(/"/g,'\\"')}"`):o(e))).join("%2C%20")+"%5D":"bigint"==typeof e?`${e}n`:encodeURIComponent(String(null===Object.getPrototypeOf(e)?{...e}:e))}function i([e,t]){return`${e}=${o(t)}`}var a=class extends Error{context;constructor(...[e,t]){super(function(e,t={}){if(n)return function(e,t={}){return r[e].replace(/(?<!\\)\$(\w+)/g,((e,n)=>n in t?`${t[n]}`:e))}(e,t);{let n=`Solana error #${e}; Decode this error by running \`npx @solana/errors decode ${e}`;return Object.keys(t).length&&(n+=` $"${function(e){return Object.entries(e).map(i).join("&")}(t)}"`),`${n}\``}}(e,t)),this.context={__code:e,...t},this.name="SolanaError"}};t.SOLANA_ERROR__RPC_INTEGER_OVERFLOW=3,t.SOLANA_ERROR__TRANSACTION_MISSING_SIGNATURES=1,t.SOLANA_ERROR__TRANSACTION_SIGNATURE_NOT_COMPUTABLE=2,t.SolanaError=a,t.isSolanaError=function(e,t){return!!(e instanceof Error&&"SolanaError"===e.name)&&(void 0===t||e.context.__code===t)}},364:(e,t)=>{"use strict";t.pipe=function(e,...t){return t.reduce(((e,t)=>t(e)),e)}},536:(e,t)=>{"use strict";var n=(e=>(e[e.WRITABLE_SIGNER=3]="WRITABLE_SIGNER",e[e.READONLY_SIGNER=2]="READONLY_SIGNER",e[e.WRITABLE=1]="WRITABLE",e[e.READONLY=0]="READONLY",e))(n||{});t.AccountRole=n,t.downgradeRoleToNonSigner=function(e){return-3&e},t.downgradeRoleToReadonly=function(e){return-2&e},t.isSignerRole=function(e){return e>=2},t.isWritableRole=function(e){return 0!=(1&e)},t.mergeRoles=function(e,t){return e|t},t.upgradeRoleToSigner=function(e){return 2|e},t.upgradeRoleToWritable=function(e){return 1|e}},964:(e,t,n)=>{"use strict";var r,o=n(220),i=n(864);function a(e){r||(r=i.getBase58Encoder());try{if(e.length<64||e.length>88)throw new Error("Expected input string to decode to a byte array of length 64.");const t=r.encode(e).byteLength;if(64!==t)throw new Error(`Expected input string to decode to a byte array of length 64. Actual length: ${t}`)}catch(t){throw new Error(`\`${e}\` is not a signature`,{cause:t})}}t.assertIsSignature=a,t.createPrivateKeyFromBytes=async function(e,t){if(32!==e.byteLength)throw new Error("Private key bytes must be of length 32");const n=function(e){return new Uint8Array([48,46,2,1,0,48,5,6,3,43,101,112,4,34,4,32,...e])}(e);return await crypto.subtle.importKey("pkcs8",n,"Ed25519",t??!1,["sign"])},t.generateKeyPair=async function(){return await o.assertKeyGenerationIsAvailable(),await crypto.subtle.generateKey("Ed25519",!1,["sign","verify"])},t.isSignature=function(e){return r||(r=i.getBase58Encoder()),!(e.length<64||e.length>88)&&64===r.encode(e).byteLength},t.signBytes=async function(e,t){await o.assertSigningCapabilityIsAvailable();const n=await crypto.subtle.sign("Ed25519",e,t);return new Uint8Array(n)},t.signature=function(e){return a(e),e},t.verifySignature=async function(e,t,n){return await o.assertVerificationCapabilityIsAvailable(),await crypto.subtle.verify("Ed25519",e,t,n)}},272:(e,t,n)=>{"use strict";var r=n(112),o=n(660),i=e=>({__option:"Some",value:e}),a=()=>({__option:"None"}),s=e=>!!(e&&"object"==typeof e&&"__option"in e&&("Some"===e.__option&&"value"in e||"None"===e.__option)),c=e=>"Some"===e.__option,u=e=>null!==e?i(e):{__option:"None"};function d(e,t={}){const n=t.prefix??o.getU8Encoder(),i=t.fixed??!1,a=r.isFixedSize(e)&&r.isFixedSize(n)&&0===e.fixedSize;if(i||a){r.assertIsFixedSize(e,"Fixed options can only be used with fixed-size codecs."),r.assertIsFixedSize(n,"Fixed options can only be used with fixed-size prefix.");const t=n.fixedSize+e.fixedSize;return r.createEncoder({fixedSize:t,write:(r,o,i)=>{const a=s(r)?r:u(r),d=n.write(Number(c(a)),o,i);return c(a)&&e.write(a.value,o,d),i+t}})}return r.createEncoder({getSizeFromValue:t=>{const o=s(t)?t:u(t);return r.getEncodedSize(Number(c(o)),n)+(c(o)?r.getEncodedSize(o.value,e):0)},maxSize:f([n,e].map(g))??void 0,write:(t,r,o)=>{const i=s(t)?t:u(t);return o=n.write(Number(c(i)),r,o),c(i)&&(o=e.write(i.value,r,o)),o}})}function l(e,t={}){const n=t.prefix??o.getU8Decoder(),a=t.fixed??!1;let s=null;const c=r.isFixedSize(e)&&r.isFixedSize(n)&&0===e.fixedSize;return(a||c)&&(r.assertIsFixedSize(e,"Fixed options can only be used with fixed-size codecs."),r.assertIsFixedSize(n,"Fixed options can only be used with fixed-size prefix."),s=n.fixedSize+e.fixedSize),r.createDecoder({...null===s?{maxSize:f([n,e].map(g))??void 0}:{fixedSize:s},read:(t,r)=>{if(t.length-r<=0)return[{__option:"None"},r];const[o,a]=n.read(t,r);if(0===o)return[{__option:"None"},null!==s?r+s:a];const[c,u]=e.read(t,a);return[i(c),null!==s?r+s:u]}})}function f(e){return e.reduce(((e,t)=>null===e||null===t?null:e+t),0)}function g(e){return r.isFixedSize(e)?e.fixedSize:e.maxSize??null}t.getOptionCodec=function(e,t={}){return r.combineCodec(d(e,t),l(e,t))},t.getOptionDecoder=l,t.getOptionEncoder=d,t.isNone=e=>"None"===e.__option,t.isOption=s,t.isSome=c,t.none=a,t.some=i,t.unwrapOption=function(e,t){return c(e)?e.value:t?t():null},t.unwrapOptionRecursively=function e(t,n){if(!t||ArrayBuffer.isView(t))return t;const r=t=>n?e(t,n):e(t);return s(t)?c(t)?r(t.value):n?n():null:Array.isArray(t)?t.map(r):"object"==typeof t?Object.fromEntries(Object.entries(t).map((([e,t])=>[e,r(t)]))):t},t.wrapNullable=u},156:(e,t)=>{"use strict";t.resolveTransactionError=function(e,t,n){const r=e.message+"\n"+(e.logs??[]).join("\n"),o=r.match(/Error processing Instruction (\d+)/)?.[1]??null,i=o?parseInt(o,10):null;if(null===i)return e;const a=r.match(/Custom program error: (0x[a-f0-9]+)/i)?.[1]??null,s=a?parseInt(a,16):null;if(null===s)return e;const c=t.instructions[i]?.programAddress??null;if(!c)return e;const u=n.find((e=>e.address===c&&void 0!==e.getErrorFromCode))??null;return u?u.getErrorFromCode(s,e):e}},324:(e,t,n)=>{"use strict";var r=n(808);function o(e){return"bigint"==typeof e?Number(e):e}var i={accountNotifications:1,blockNotifications:1,getAccountInfo:1,getBalance:1,getBlock:1,getBlockHeight:0,getBlockProduction:0,getBlocks:2,getBlocksWithLimit:2,getConfirmedBlock:1,getConfirmedBlocks:1,getConfirmedBlocksWithLimit:2,getConfirmedSignaturesForAddress2:1,getConfirmedTransaction:1,getEpochInfo:0,getFeeCalculatorForBlockhash:1,getFeeForMessage:1,getFees:1,getInflationGovernor:0,getInflationReward:1,getLargestAccounts:0,getLatestBlockhash:0,getLeaderSchedule:1,getMinimumBalanceForRentExemption:1,getMultipleAccounts:1,getProgramAccounts:1,getRecentBlockhash:1,getSignaturesForAddress:1,getSlot:0,getSlotLeader:0,getStakeActivation:1,getStakeMinimumDelegation:0,getSupply:0,getTokenAccountBalance:1,getTokenAccountsByDelegate:2,getTokenAccountsByOwner:2,getTokenLargestAccounts:1,getTokenSupply:1,getTransaction:1,getTransactionCount:0,getVoteAccounts:0,isBlockhashValid:1,logsNotifications:1,programNotifications:1,requestAirdrop:2,sendTransaction:1,signatureNotifications:1,simulateTransaction:1},a={};function s(e){return function t(n,r){if(Array.isArray(n))return n.map(((e,n)=>{const o={...r,keyPath:[...r.keyPath,n]};return t(e,o)}));if("object"==typeof n&&null!==n){const e={};for(const o in n){if(!Object.prototype.hasOwnProperty.call(n,o))continue;const i={...r,keyPath:[...r.keyPath,o]};e[o]=t(n[o],i)}return e}return e.reduce(((e,t)=>t(e,r)),n)}}function c(e){const t=e?.defaultCommitment,n=e?.onIntegerOverflow;return(e,r)=>{var a;const c=s([...n?[(a=(...e)=>n(r,...e),(e,{keyPath:t})=>("bigint"==typeof e&&a&&(e>Number.MAX_SAFE_INTEGER||e<-Number.MAX_SAFE_INTEGER)&&a(t,e),e))]:[],o])(e,{keyPath:[]});if(!Array.isArray(c))return c;const u=i[r];return null==u?c:function({commitmentPropertyName:e,params:t,optionsObjectPositionInParams:n,overrideCommitment:r}){const o=t[n];if(void 0===o||o&&"object"==typeof o&&!Array.isArray(o))if(o&&e in o){if(!o[e]||"finalized"===o[e]){const r=[...t],{[e]:i,...a}=o;return Object.keys(a).length>0?r[n]=a:n===r.length-1?r.length--:r[n]=void 0,r}}else if("finalized"!==r){const i=[...t];return i[n]={...o,[e]:r},i}return t}({commitmentPropertyName:"sendTransaction"===r?"preflightCommitment":"commitment",optionsObjectPositionInParams:u,overrideCommitment:t,params:c})}}var u,d,l=[["data","parsed","info","tokenAmount","decimals"],["data","parsed","info","tokenAmount","uiAmount"],["data","parsed","info","rentExemptReserve","decimals"],["data","parsed","info","rentExemptReserve","uiAmount"],["data","parsed","info","delegatedAmount","decimals"],["data","parsed","info","delegatedAmount","uiAmount"],["data","parsed","info","extensions",a,"state","olderTransferFee","transferFeeBasisPoints"],["data","parsed","info","extensions",a,"state","newerTransferFee","transferFeeBasisPoints"],["data","parsed","info","extensions",a,"state","preUpdateAverageRate"],["data","parsed","info","extensions",a,"state","currentRate"]],f=[...l,["data","parsed","info","lastExtendedSlotStartIndex"],["data","parsed","info","slashPenalty"],["data","parsed","info","warmupCooldownRate"],["data","parsed","info","decimals"],["data","parsed","info","numRequiredSigners"],["data","parsed","info","numValidSigners"],["data","parsed","info","stake","delegation","warmupCooldownRate"],["data","parsed","info","exemptionThreshold"],["data","parsed","info","burnPercent"],["data","parsed","info","commission"],["data","parsed","info","votes",a,"confirmationCount"]];function g(e){return function(t,{keyPath:n}){return"number"==typeof t&&Number.isInteger(t)&&!function(e,t){return t.some((t=>{if(t.length!==e.length)return!1;for(let n=e.length-1;n>=0;n--){const r=e[n],o=t[n];if(o!==r&&(o!==a||"number"!=typeof r))return!1}return!0}))}(n,e)?BigInt(t):t}}function m(e,t){return s([g((t?(d||(d={getAccountInfo:f.map((e=>["value",...e])),getBlock:[["blockTime"],["transactions",a,"meta","preTokenBalances",a,"accountIndex"],["transactions",a,"meta","preTokenBalances",a,"uiTokenAmount","decimals"],["transactions",a,"meta","postTokenBalances",a,"accountIndex"],["transactions",a,"meta","postTokenBalances",a,"uiTokenAmount","decimals"],["transactions",a,"meta","rewards",a,"commission"],["transactions",a,"meta","innerInstructions",a,"index"],["transactions",a,"meta","innerInstructions",a,"instructions",a,"programIdIndex"],["transactions",a,"meta","innerInstructions",a,"instructions",a,"accounts",a],["transactions",a,"transaction","message","addressTableLookups",a,"writableIndexes",a],["transactions",a,"transaction","message","addressTableLookups",a,"readonlyIndexes",a],["transactions",a,"transaction","message","instructions",a,"programIdIndex"],["transactions",a,"transaction","message","instructions",a,"accounts",a],["transactions",a,"transaction","message","header","numReadonlySignedAccounts"],["transactions",a,"transaction","message","header","numReadonlyUnsignedAccounts"],["transactions",a,"transaction","message","header","numRequiredSignatures"],["rewards",a,"commission"]],getBlockTime:[[]],getClusterNodes:[[a,"featureSet"],[a,"shredVersion"]],getInflationGovernor:[["initial"],["foundation"],["foundationTerm"],["taper"],["terminal"]],getInflationRate:[["foundation"],["total"],["validator"]],getInflationReward:[[a,"commission"]],getMultipleAccounts:f.map((e=>["value",a,...e])),getProgramAccounts:f.flatMap((e=>[["value",a,"account",...e],[a,"account",...e]])),getRecentPerformanceSamples:[[a,"samplePeriodSecs"]],getTokenAccountBalance:[["value","decimals"],["value","uiAmount"]],getTokenAccountsByDelegate:l.map((e=>["value",a,"account",...e])),getTokenAccountsByOwner:l.map((e=>["value",a,"account",...e])),getTokenLargestAccounts:[["value",a,"decimals"],["value",a,"uiAmount"]],getTokenSupply:[["value","decimals"],["value","uiAmount"]],getTransaction:[["meta","preTokenBalances",a,"accountIndex"],["meta","preTokenBalances",a,"uiTokenAmount","decimals"],["meta","postTokenBalances",a,"accountIndex"],["meta","postTokenBalances",a,"uiTokenAmount","decimals"],["meta","rewards",a,"commission"],["meta","innerInstructions",a,"index"],["meta","innerInstructions",a,"instructions",a,"programIdIndex"],["meta","innerInstructions",a,"instructions",a,"accounts",a],["transaction","message","addressTableLookups",a,"writableIndexes",a],["transaction","message","addressTableLookups",a,"readonlyIndexes",a],["transaction","message","instructions",a,"programIdIndex"],["transaction","message","instructions",a,"accounts",a],["transaction","message","header","numReadonlySignedAccounts"],["transaction","message","header","numReadonlyUnsignedAccounts"],["transaction","message","header","numRequiredSignatures"]],getVersion:[["feature-set"]],getVoteAccounts:[["current",a,"commission"],["delinquent",a,"commission"]],simulateTransaction:f.map((e=>["value","accounts",a,...e]))}),d)[t]:void 0)??[])])(e,{keyPath:[]})}function p(e,t){return s([g((t?(u||(u={accountNotifications:f.map((e=>["value",...e])),blockNotifications:[["value","block","blockTime"],["value","block","transactions",a,"meta","preTokenBalances",a,"accountIndex"],["value","block","transactions",a,"meta","preTokenBalances",a,"uiTokenAmount","decimals"],["value","block","transactions",a,"meta","postTokenBalances",a,"accountIndex"],["value","block","transactions",a,"meta","postTokenBalances",a,"uiTokenAmount","decimals"],["value","block","transactions",a,"meta","rewards",a,"commission"],["value","block","transactions",a,"meta","innerInstructions",a,"index"],["value","block","transactions",a,"meta","innerInstructions",a,"instructions",a,"programIdIndex"],["value","block","transactions",a,"meta","innerInstructions",a,"instructions",a,"accounts",a],["value","block","transactions",a,"transaction","message","addressTableLookups",a,"writableIndexes",a],["value","block","transactions",a,"transaction","message","addressTableLookups",a,"readonlyIndexes",a],["value","block","transactions",a,"transaction","message","instructions",a,"programIdIndex"],["value","block","transactions",a,"transaction","message","instructions",a,"accounts",a],["value","block","transactions",a,"transaction","message","header","numReadonlySignedAccounts"],["value","block","transactions",a,"transaction","message","header","numReadonlyUnsignedAccounts"],["value","block","transactions",a,"transaction","message","header","numRequiredSignatures"],["value","block","rewards",a,"commission"]],programNotifications:f.flatMap((e=>[["value",a,"account",...e],[a,"account",...e]]))}),u)[t]:void 0)??[])])(e,{keyPath:[]})}function h(e){return r.createJsonRpcSubscriptionsApi({parametersTransformer:c(e),responseTransformer:p,subscribeNotificationNameTransformer:e=>e.replace(/Notifications$/,"Subscribe"),unsubscribeNotificationNameTransformer:e=>e.replace(/Notifications$/,"Unsubscribe")})}t.createSolanaRpcApi=function(e){return r.createJsonRpcApi({parametersTransformer:c(e),responseTransformer:m})},t.createSolanaRpcSubscriptionsApi=function(e){return h(e)},t.createSolanaRpcSubscriptionsApi_INTERNAL=h,t.createSolanaRpcSubscriptionsApi_UNSTABLE=function(e){return h(e)}},48:()=>{},808:(e,t)=>{"use strict";var n=(()=>!1)(),r=class extends Error{code;data;constructor(e){super(`JSON-RPC 2.0 error (${e.code}): ${e.message}`),Error.captureStackTrace(this,this.constructor),this.code=e.code,this.data=e.data}get name(){return"SolanaJsonRpcError"}},o=0;function i(){const e=o;return o=(o+1)%Number.MAX_SAFE_INTEGER,e}function a(e,t){return{id:i(),jsonrpc:"2.0",method:e,params:t}}var s=globalThis.fetch,c=class extends Error{statusCode;constructor(e){super(`HTTP error (${e.statusCode}): ${e.message}`),Error.captureStackTrace(this,this.constructor),this.statusCode=e.statusCode}get name(){return"SolanaHttpError"}},u={accept:!0,"content-length":!0,"content-type":!0},d={"accept-charset":!0,"accept-encoding":!0,"access-control-request-headers":!0,"access-control-request-method":!0,connection:!0,"content-length":!0,cookie:!0,date:!0,dnt:!0,expect:!0,host:!0,"keep-alive":!0,origin:!0,"permissions-policy":!0,referer:!0,te:!0,trailer:!0,"transfer-encoding":!0,upgrade:!0,via:!0},l=globalThis.WebSocket,f=Symbol(n?"This symbol is thrown from a socket's iterator when the connection is explicitly aborted by the user":void 0);t.createHttpTransport=function({headers:e,url:t}){n&&e&&function(e){const t=Object.keys(e).filter((e=>{const t=e.toLowerCase();return!0===u[e.toLowerCase()]||!0===d[e.toLowerCase()]||t.startsWith("proxy-")||t.startsWith("sec-")}));if(t.length>0)throw new Error(`${t.length>1?"These headers are":"This header is"} forbidden: \`${t.join("`, `")}\`. Learn more at https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.`)}(e);const r=e&&function(e){const t={};for(const n in e)t[n.toLowerCase()]=e[n];return t}(e);return async function({payload:e,signal:n}){const o=JSON.stringify(e),i={body:o,headers:{...r,accept:"application/json","content-length":o.length.toString(),"content-type":"application/json; charset=utf-8"},method:"POST",signal:n},a=await s(t,i);if(!a.ok)throw new c({message:a.statusText,statusCode:a.status});return await a.json()}},t.createJsonRpc=function(e){return function(e){return new Proxy(e.api,{defineProperty:()=>!1,deleteProperty:()=>!1,get:(t,n,o)=>function(...i){const s=n.toString(),c=Reflect.get(t,s,o),u=c?c(...i):{methodName:s,params:i};return function(e,t){return{async send(n){const{methodName:o,params:i,responseTransformer:s}=t,c=a(o,i),u=await e.transport({payload:c,signal:n?.abortSignal});if("error"in u)throw new r(u.error);return s?s(u.result,o):u.result}}}(e,u)}})}(e)},t.createJsonRpcApi=function(e){return new Proxy({},{defineProperty:()=>!1,deleteProperty:()=>!1,get(...t){const[n,r]=t,o=r.toString();return function(...t){const n=e?.parametersTransformer?e?.parametersTransformer(t,o):t;return{methodName:o,params:n,responseTransformer:e?.responseTransformer?e?.responseTransformer:e=>e}}}})},t.createJsonRpcSubscriptionsApi=function(e){return new Proxy({},{defineProperty:()=>!1,deleteProperty:()=>!1,get(...t){const[n,r]=t,o=r.toString();return function(...t){return{params:e?.parametersTransformer?e?.parametersTransformer(t,o):t,responseTransformer:e?.responseTransformer?e?.responseTransformer:e=>e,subscribeMethodName:e?.subscribeNotificationNameTransformer?e?.subscribeNotificationNameTransformer(o):o,unsubscribeMethodName:e?.unsubscribeNotificationNameTransformer?e?.unsubscribeNotificationNameTransformer(o):o}}}})},t.createJsonSubscriptionRpc=function(e){return function(e){return new Proxy(e.api,{defineProperty:()=>!1,deleteProperty:()=>!1,get:(t,n,o)=>function(...i){const s=n.toString(),c=Reflect.get(t,s,o);if(!1===n.toString().endsWith("Notifications")&&!c)throw new Error("Either the notification name must end in 'Notifications' or the API must supply a subscription creator function to map between the notification name and the subscribe/unsubscribe method names.");const u=c?c(...i):{params:i,subscribeMethodName:s.replace(/Notifications$/,"Subscribe"),unsubscribeMethodName:s.replace(/Notifications$/,"Unsubscribe")};return function(e,{params:t,subscribeMethodName:n,unsubscribeMethodName:o,responseTransformer:i}){return{async subscribe({abortSignal:s}){let c;function u(){if(void 0!==c){const e=a(o,[c]);f.send_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(e).finally((()=>{d.abort()}))}else d.abort()}s.throwIfAborted(),s.addEventListener("abort",u);const d=new AbortController,l=a(n,t),f=await e.transport({payload:l,signal:d.signal});var g,m;g=f,m=function(){s.removeEventListener("abort",u)},(async()=>{try{for await(const e of g);}catch{}finally{m()}})();for await(const e of f)if("id"in e&&e.id===l.id){if("error"in e)throw new r(e.error);c=e.result;break}if(null==c)throw new Error("Failed to obtain a subscription id from the server");return{async*[Symbol.asyncIterator](){for await(const e of f){if(!("params"in e)||e.params.subscription!==c)continue;const t=e.params.result;yield i?i(t,n):t}}}}}}(e,u)}})}(e)},t.createWebSocketTransport=function({sendBufferHighWatermark:e,url:t}){if(!1===/^wss?:/i.test(t)){const e=t.match(/^([^:]+):/);throw new DOMException(e?`Failed to construct 'WebSocket': The URL's scheme must be either 'ws' or 'wss'. '${e[1]}:' is not allowed.`:`Failed to construct 'WebSocket': The URL '${t}' is invalid.`)}return async function({payload:n,signal:r}){r?.throwIfAborted();const o=await async function({sendBufferHighWatermark:e,signal:t,url:n}){return new Promise(((r,o)=>{t.addEventListener("abort",s,{once:!0});const i=new Map;function a(e){const t=[...i.values()].filter((e=>e.__hasPolled)).map((({onError:e})=>e));i.clear(),t.forEach((t=>{try{t(e)}catch{}}))}function s(){a(f),p.readyState!==l.CLOSED&&p.readyState!==l.CLOSING&&p.close(1e3)}function c(e){d||o(new Error("WebSocket failed to connect",{cause:e}))}let u,d=!1;function g(){d=!0,r({async send(t){const n=JSON.stringify(t);if(!u&&p.readyState===l.OPEN&&p.bufferedAmount>e){let t;const n=new Promise(((n,r)=>{const o=setInterval((()=>{p.readyState===l.OPEN&&p.bufferedAmount>e||(clearInterval(o),u=void 0,n())}),16);t=()=>{u=void 0,clearInterval(o),r(new Error("WebSocket was closed before payload could be sent"))}}));u={onCancel:t,promise:n}}u&&await u.promise,p.send(n)},async*[Symbol.asyncIterator](){const e=Symbol();i.set(e,{__hasPolled:!1,queuedMessages:[]});try{for(;;){const t=i.get(e);if(!t)throw new Error("Invariant: WebSocket message iterator is missing state storage");if(t.__hasPolled)throw new Error("Invariant: WebSocket message iterator state is corrupt; iterated without first resolving existing message promise");const n=t.queuedMessages;if(n.length)t.queuedMessages=[],yield*n;else try{yield await new Promise(((t,n)=>{i.set(e,{__hasPolled:!0,onError:n,onMessage:t})}))}catch(e){if(e===f)return;throw new Error("WebSocket connection closed",{cause:e})}}}finally{i.delete(e)}}})}function m({data:e}){const t=JSON.parse(e);i.forEach(((e,n)=>{if(e.__hasPolled){const{onMessage:r}=e;i.set(n,{__hasPolled:!1,queuedMessages:[]}),r(t)}else e.queuedMessages.push(t)}))}const p=new l(n);p.addEventListener("close",(function e(n){u?.onCancel(),t.removeEventListener("abort",s),p.removeEventListener("close",e),p.removeEventListener("error",c),p.removeEventListener("open",g),p.removeEventListener("message",m),a(n)})),p.addEventListener("error",c),p.addEventListener("open",g),p.addEventListener("message",m)}))}({sendBufferHighWatermark:e,signal:r,url:t});return r?.throwIfAborted(),await o.send(n),{[Symbol.asyncIterator]:o[Symbol.asyncIterator].bind(o),send_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:o.send.bind(o)}}}},976:(e,t,n)=>{"use strict";var r,o=n(864);function i(e){switch(e){case"finalized":return 2;case"confirmed":return 1;case"processed":return 0;default:return(t=>{throw new Error(`Unrecognized commitment \`${e}\`.`)})()}}var a=18446744073709551615n;function s(e){if(e<0)throw new Error("Input for 64-bit unsigned integer cannot be negative");if(e>a)throw new Error("Input number is too large to be represented as a 64-bit unsigned integer")}function c(e){try{BigInt(e)}catch(t){throw new Error(`\`${e}\` cannot be parsed as a BigInt`,{cause:t})}}function u(e){if(Number.isNaN(Number(e)))throw new Error(`\`${e}\` cannot be parsed as a Number`)}function d(e){try{if(e>864e13||e<-864e13)throw new Error("Expected input number to be in the range [-8.64e15, 8.64e15]")}catch(t){throw new Error(`\`${e}\` is not a timestamp`,{cause:t})}}t.assertIsBlockhash=function(e){r||(r=o.getBase58Encoder());try{if(e.length<32||e.length>44)throw new Error("Expected input string to decode to a byte array of length 32.");const t=r.encode(e).byteLength;if(32!==t)throw new Error(`Expected input string to decode to a byte array of length 32. Actual length: ${t}`)}catch(t){throw new Error(`\`${e}\` is not a blockhash`,{cause:t})}},t.assertIsLamports=s,t.assertIsStringifiedBigInt=c,t.assertIsStringifiedNumber=u,t.assertIsUnixTimestamp=d,t.commitmentComparator=function(e,t){return e===t?0:i(e)<i(t)?-1:1},t.devnet=function(e){return e},t.isLamports=function(e){return e>=0&&e<=a},t.isStringifiedBigInt=function(e){try{return BigInt(e),!0}catch(e){return!1}},t.isStringifiedNumber=function(e){return!Number.isNaN(Number(e))},t.isUnixTimestamp=function(e){return!(e>864e13||e<-864e13)},t.lamports=function(e){return s(e),e},t.mainnet=function(e){return e},t.stringifiedBigInt=function(e){return c(e),e},t.stringifiedNumber=function(e){return u(e),e},t.testnet=function(e){return e},t.unixTimestamp=function(e){return d(e),e}},672:(e,t,n)=>{"use strict";var r=n(536),o=n(868),i=n(964),a=n(296);function s(e){const t={};return e.forEach((e=>{if(t[e.address]){if(t[e.address]!==e)throw new Error(`Multiple distinct signers were identified for address "${e.address}". Please ensure that you are using the same signer instance for each address.`)}else t[e.address]=e})),Object.values(t)}function c(e){return s((e.accounts??[]).flatMap((e=>"signer"in e?e.signer:[])))}function u(e){return s(e.instructions.flatMap(c))}function d(e,t){if(!t.accounts||0===t.accounts.length)return t;const n=new Map(s(e).map((e=>[e.address,e])));return Object.freeze({...t,accounts:t.accounts.map((e=>{const t=n.get(e.address);return r.isSignerRole(e.role)&&!("signer"in e)&&t?Object.freeze({...e,signer:t}):e}))})}function l(e){return"signMessages"in e&&"function"==typeof e.signMessages}function f(e){return"signTransactions"in e&&"function"==typeof e.signTransactions}function g(e){return"keyPair"in e&&"object"==typeof e.keyPair&&l(e)&&f(e)}async function m(e){const t=await o.getAddressFromPublicKey(e.publicKey),n={address:t,keyPair:e,signMessages:n=>Promise.all(n.map((async n=>Object.freeze({[t]:await i.signBytes(e.privateKey,n.content)})))),signTransactions:n=>Promise.all(n.map((async n=>{const r=await a.partiallySignTransaction([e],n);return Object.freeze({[t]:r.signatures[t]})})))};return Object.freeze(n)}function p(e){return o.isAddress(e.address)&&"modifyAndSignMessages"in e&&"function"==typeof e.modifyAndSignMessages}function h(e){return l(e)||p(e)}function y(e){return"modifyAndSignTransactions"in e&&"function"==typeof e.modifyAndSignTransactions}function b(e){return"signAndSendTransactions"in e&&"function"==typeof e.signAndSendTransactions}function w(e){return f(e)||y(e)||b(e)}async function S(e,t={}){const{partialSigners:n,modifyingSigners:r}=E(s(u(e).filter(w)),{identifySendingSigner:!1});return A(e,r,n,t.abortSignal)}function E(e,t={}){const n=t.identifySendingSigner??1?function(e){const t=e.filter(b);if(0===t.length)return null;const n=t.filter((e=>!y(e)&&!f(e)));return n.length>0?n[0]:t[0]}(e):null,r=e.filter((e=>e!==n&&(y(e)||f(e)))),o=function(e){const t=e.filter(y);if(0===t.length)return[];const n=t.filter((e=>!f(e)));return n.length>0?n:[t[0]]}(r),i=r.filter(f).filter((e=>!o.includes(e)));return Object.freeze({modifyingSigners:o,partialSigners:i,sendingSigner:n})}async function A(e,t=[],n=[],r){const o=await t.reduce((async(e,t)=>{r?.throwIfAborted();const[n]=await t.modifyAndSignTransactions([await e],{abortSignal:r});return Object.freeze(n)}),Promise.resolve(e));r?.throwIfAborted();const i=await Promise.all(n.map((async e=>{const[t]=await e.signTransactions([o],{abortSignal:r});return t}))),a={...o,signatures:Object.freeze(i.reduce(((e,t)=>({...e,...t})),o.signatures??{}))};return Object.freeze(a)}var v=globalThis.TextEncoder;function x(e){const t=u(e).filter(b);if(0===t.length){const e=new Error("No `TransactionSendingSigner` was identified.");throw e.name="MissingTransactionSendingSignerError",e}if(t.filter((e=>!f(e)&&!y(e))).length>1){const e=new Error("More than one `TransactionSendingSigner` was identified.");throw e.name="MultipleTransactionSendingSignersError",e}}t.addSignersToInstruction=d,t.addSignersToTransaction=function(e,t){return 0===t.instructions.length?t:Object.freeze({...t,instructions:t.instructions.map((t=>d(e,t)))})},t.assertIsKeyPairSigner=function(e){if(!g(e))throw new Error("The provided value does not implement the KeyPairSigner interface")},t.assertIsMessageModifyingSigner=function(e){if(!p(e))throw new Error("The provided value does not implement the MessageModifyingSigner interface")},t.assertIsMessagePartialSigner=function(e){if(!l(e))throw new Error("The provided value does not implement the MessagePartialSigner interface")},t.assertIsMessageSigner=function(e){if(!h(e))throw new Error("The provided value does not implement any of the MessageSigner interfaces")},t.assertIsTransactionModifyingSigner=function(e){if(!y(e))throw new Error("The provided value does not implement the TransactionModifyingSigner interface")},t.assertIsTransactionPartialSigner=function(e){if(!f(e))throw new Error("The provided value does not implement the TransactionPartialSigner interface")},t.assertIsTransactionSendingSigner=function(e){if(!b(e))throw new Error("The provided value does not implement the TransactionSendingSigner interface")},t.assertIsTransactionSigner=function(e){if(!w(e))throw new Error("The provided value does not implement any of the TransactionSigner interfaces")},t.assertIsTransactionWithSingleSendingSigner=x,t.createNoopSigner=function(e){const t={address:e,signMessages:async e=>e.map((()=>Object.freeze({}))),signTransactions:async e=>e.map((()=>Object.freeze({})))};return Object.freeze(t)},t.createSignableMessage=function(e,t={}){return Object.freeze({content:"string"==typeof e?(new v).encode(e):e,signatures:Object.freeze({...t})})},t.createSignerFromKeyPair=m,t.generateKeyPairSigner=async function(){return m(await i.generateKeyPair())},t.getSignersFromInstruction=c,t.getSignersFromTransaction=u,t.isKeyPairSigner=g,t.isMessageModifyingSigner=p,t.isMessagePartialSigner=l,t.isMessageSigner=h,t.isTransactionModifyingSigner=y,t.isTransactionPartialSigner=f,t.isTransactionSendingSigner=b,t.isTransactionSigner=w,t.isTransactionWithSingleSendingSigner=function(e){try{return x(e),!0}catch{return!1}},t.partiallySignTransactionWithSigners=S,t.signAndSendTransactionWithSigners=async function(e,t={}){const n=t.abortSignal,{partialSigners:r,modifyingSigners:o,sendingSigner:i}=E(s(u(e).filter(w)));n?.throwIfAborted();const a=await A(e,o,r,n);if(!i)throw new Error("No `TransactionSendingSigner` was identified. Please provide a valid `ITransactionWithSingleSendingSigner` transaction.");n?.throwIfAborted();const[c]=await i.signAndSendTransactions([a],{abortSignal:n});return n?.throwIfAborted(),c},t.signTransactionWithSigners=async function(e,t={}){const n=await S(e,t);return a.assertTransactionIsFullySigned(n),n}},296:(e,t,n)=>{"use strict";var r,o=n(864),i=n(868),a=n(364),s=n(112),c=n(848),u=n(660),d=n(916),l=n(964);function f(e){if("signatures"in e){const{signatures:t,...n}=e;return n}return e}function g(e,t){if("lifetimeConstraint"in t&&t.lifetimeConstraint.blockhash===e.blockhash&&t.lifetimeConstraint.lastValidBlockHeight===e.lastValidBlockHeight)return t;const n={...f(t),lifetimeConstraint:e};return Object.freeze(n),n}function m({version:e}){const t={instructions:[],version:e};return Object.freeze(t),t}var p=(e=>(e[e.WRITABLE_SIGNER=3]="WRITABLE_SIGNER",e[e.READONLY_SIGNER=2]="READONLY_SIGNER",e[e.WRITABLE=1]="WRITABLE",e[e.READONLY=0]="READONLY",e))(p||{}),h=1;function y(e){return e>=2}function b(e){return 0!=(e&h)}function w(e,t){return e|t}var S="SysvarRecentB1ockHashes11111111111111111111",E="11111111111111111111111111111111";function A(e,t){return{accounts:[{address:e,role:p.WRITABLE},{address:S,role:p.READONLY},{address:t,role:p.READONLY_SIGNER}],data:new Uint8Array([4,0,0,0]),programAddress:E}}function v(e){return e.programAddress===E&&null!=e.data&&4===(t=e.data).byteLength&&4===t[0]&&0===t[1]&&0===t[2]&&0===t[3]&&3===e.accounts?.length&&null!=e.accounts[0].address&&e.accounts[0].role===p.WRITABLE&&e.accounts[1].address===S&&e.accounts[1].role===p.READONLY&&null!=e.accounts[2].address&&y(e.accounts[2].role);var t}function x(e){return"lifetimeConstraint"in e&&"string"==typeof e.lifetimeConstraint.nonce&&null!=e.instructions[0]&&v(e.instructions[0])}function T({nonce:e,nonceAccountAddress:t,nonceAuthorityAddress:n},r){let o;const i=r.instructions[0];if(i&&v(i))if(function(e,t,n){return e.accounts[0].address===t&&e.accounts[2].address===n}(i,t,n)){if(x(r)&&r.lifetimeConstraint.nonce===e)return r;o=[i,...r.instructions.slice(1)]}else o=[A(t,n),...r.instructions.slice(1)];else o=[A(t,n),...r.instructions];const a={...f(r),instructions:o,lifetimeConstraint:{nonce:e}};return Object.freeze(a),a}function I(e,t){if("feePayer"in t&&e===t.feePayer)return t;const n={...f(t),feePayer:e};return Object.freeze(n),n}function k(e,t){const n={...f(t),instructions:[...t.instructions,e]};return Object.freeze(n),n}function z(e,t){const{compiledMessage:n}=e,r=n.staticAccounts[0];if(!r)throw new Error("No fee payer set in CompiledTransaction");const o=function(e){const{header:t}=e,n=t.numSignerAccounts-t.numReadonlySignerAccounts,r=e.staticAccounts.length-t.numSignerAccounts-t.numReadonlyNonSignerAccounts,o=[];let i=0;for(let t=0;t<n;t++)o.push({address:e.staticAccounts[i],role:p.WRITABLE_SIGNER}),i++;for(let n=0;n<t.numReadonlySignerAccounts;n++)o.push({address:e.staticAccounts[i],role:p.READONLY_SIGNER}),i++;for(let t=0;t<r;t++)o.push({address:e.staticAccounts[i],role:p.WRITABLE}),i++;for(let n=0;n<t.numReadonlyNonSignerAccounts;n++)o.push({address:e.staticAccounts[i],role:p.READONLY}),i++;return o}(n),s="addressTableLookups"in n&&void 0!==n.addressTableLookups&&n.addressTableLookups.length>0?function(e,t){const n=e.map((e=>e.lookupTableAddress)).filter((e=>void 0===t[e]));if(n.length>0){const e=n.join(", ");throw new Error(`Addresses not provided for lookup tables: [${e}]`)}const r=[],o=[];for(const n of e){const e=t[n.lookupTableAddress],i=Math.max(...n.readableIndices,...n.writableIndices);if(i>=e.length)throw new Error(`Cannot look up index ${i} in lookup table [${n.lookupTableAddress}]. The lookup table may have been extended since the addresses provided were retrieved.`);const a=n.readableIndices.map((t=>({address:e[t],addressIndex:t,lookupTableAddress:n.lookupTableAddress,role:p.READONLY})));r.push(...a);const s=n.writableIndices.map((t=>({address:e[t],addressIndex:t,lookupTableAddress:n.lookupTableAddress,role:p.WRITABLE})));o.push(...s)}return[...o,...r]}(n.addressTableLookups,t?.addressesByLookupTableAddress??{}):[],c=[...o,...s],u=n.instructions.map((e=>function(e,t){const n=t[e.programAddressIndex]?.address;if(!n)throw new Error(`Could not find program address at index ${e.programAddressIndex}`);const r=e.accountIndices?.map((e=>t[e])),{data:o}=e;return{programAddress:n,...r&&r.length?{accounts:r}:{},...o&&o.length?{data:o}:{}}}(e,c))),d=u[0],l=function(e,t,n){if(t&&v(t)){const n=t.accounts[0].address;i.assertIsAddress(n);const r=t.accounts[2].address;return i.assertIsAddress(r),{nonce:e,nonceAccountAddress:n,nonceAuthorityAddress:r}}return{blockhash:e,lastValidBlockHeight:n??2n**64n-1n}}(n.lifetimeToken,d,t?.lastValidBlockHeight),f=function(e){const{compiledMessage:{staticAccounts:t},signatures:n}=e;return n.reduce(((e,n,r)=>{if(n.every((e=>0===e)))return e;const o=t[r];return{...e,[o]:n}}),{})}(e);return a.pipe(m({version:n.version}),(e=>I(r,e)),(e=>u.reduce(((e,t)=>k(t,e)),e)),(e=>"blockhash"in l?g(l,e):T(l,e)),(e=>Object.keys(f).length>0?{...e,signatures:f}:e))}function C(e,t,n){e[t]=n(e[t]??{role:p.READONLY})}var O,B,N,D,R,P,_=Symbol("AddressMapTypeProperty");function U(e){const t={};for(const n of e){if(!("lookupTableAddress"in n))continue;const e=t[n.lookupTableAddress]||={readableIndices:[],writableIndices:[]};n.role===p.WRITABLE?e.writableIndices.push(n.addressIndex):e.readableIndices.push(n.addressIndex)}return Object.keys(t).sort(i.getAddressComparator()).map((e=>({lookupTableAddress:e,...t[e]})))}function L(e){let t=0,n=0,r=0;for(const o of e){if("lookupTableAddress"in o)break;const e=b(o.role);y(o.role)?(r++,e||n++):e||t++}return{numReadonlyNonSignerAccounts:t,numReadonlySignerAccounts:n,numSignerAccounts:r}}function j(e,t){const n=function(e){const t={};for(const[n,r]of e.entries())t[r.address]=n;return t}(t);return e.map((({accounts:e,data:t,programAddress:r})=>({programAddressIndex:n[r],...e?{accountIndices:e.map((({address:e})=>n[e]))}:null,...t?{data:t}:null})))}function F(e){const t=e.findIndex((e=>"lookupTableAddress"in e));return(-1===t?e:e.slice(0,t)).map((({address:e})=>e))}function M(e){const t=function(e){let t;return Object.entries(e).sort((([e,n],[r,o])=>{if(n[_]!==o[_]){if(0===n[_])return-1;if(0===o[_])return 1;if(2===n[_])return-1;if(2===o[_])return 1}const a=y(n.role);if(a!==y(o.role))return a?-1:1;const s=b(n.role);return s!==b(o.role)?s?-1:1:(t||=i.getAddressComparator(),1===n[_]&&1===o[_]&&n.lookupTableAddress!==o.lookupTableAddress?t(n.lookupTableAddress,o.lookupTableAddress):t(e,r))})).map((([e,t])=>({address:e,...t})))}(function(e,t){const n={[e]:{[_]:0,role:p.WRITABLE_SIGNER}},r=new Set;for(const e of t){let t;if(C(n,e.programAddress,(t=>{if(r.add(e.programAddress),_ in t){if(b(t.role)){if(0===t[_])throw new Error(`This transaction includes an address (\`${e.programAddress}\`) which is both invoked and set as the fee payer. Program addresses may not pay fees.`);throw new Error(`This transaction includes an address (\`${e.programAddress}\`) which is both invoked and marked writable. Program addresses may not be writable.`)}if(2===t[_])return t}return{[_]:2,role:p.READONLY}})),e.accounts)for(const o of e.accounts)C(n,o.address,(e=>{const{address:n,...a}=o;if(_ in e)switch(e[_]){case 0:return e;case 1:{const n=w(e.role,a.role);if("lookupTableAddress"in a){if(e.lookupTableAddress!==a.lookupTableAddress&&(t||=i.getAddressComparator())(a.lookupTableAddress,e.lookupTableAddress)<0)return{[_]:1,...a,role:n}}else if(y(a.role))return{[_]:2,role:n};return e.role!==n?{...e,role:n}:e}case 2:{const t=w(e.role,a.role);if(r.has(o.address)){if(b(a.role))throw new Error(`This transaction includes an address (\`${o.address}\`) which is both invoked and marked writable. Program addresses may not be writable.`);return e.role!==t?{...e,role:t}:e}return"lookupTableAddress"in a&&!y(e.role)?{...a,[_]:1,role:t}:e.role!==t?{...e,role:t}:e}}return"lookupTableAddress"in a?{...a,[_]:1}:{...a,[_]:2}}))}return n}(e.feePayer,e.instructions));return{..."legacy"!==e.version?{addressTableLookups:U(t)}:null,header:L(t),instructions:j(e.instructions,t),lifetimeToken:(n=e.lifetimeConstraint,"nonce"in n?n.nonce:n.blockhash),staticAccounts:F(t),version:e.version};var n}function $(){return N||(N=u.getU8Encoder()),N}function K(){return D||(D=u.getU8Decoder()),D}var W,V=128;function H(){return c.getStructEncoder(J())}function G(){return s.mapEncoder(c.getStructEncoder([...J(),["addressTableLookups",c.getArrayEncoder((O||(O=c.getStructEncoder([["lookupTableAddress",i.getAddressEncoder()],["writableIndices",c.getArrayEncoder(u.getU8Encoder(),{size:u.getShortU16Encoder()})],["readableIndices",c.getArrayEncoder(u.getU8Encoder(),{size:u.getShortU16Encoder()})]])),O),{size:u.getShortU16Encoder()})]]),(e=>"legacy"===e.version?e:{...e,addressTableLookups:e.addressTableLookups??[]}))}function J(){return[["version",s.createEncoder({getSizeFromValue:e=>"legacy"===e?0:1,maxSize:1,write:(e,t,n)=>{if("legacy"===e)return n;if(e<0||e>127)throw new Error(`Transaction version must be in the range [0, 127]. \`${e}\` given.`);return t.set([e|V],n),n+1}})],["header",c.getStructEncoder([["numSignerAccounts",$()],["numReadonlySignerAccounts",$()],["numReadonlyNonSignerAccounts",$()]])],["staticAccounts",c.getArrayEncoder(i.getAddressEncoder(),{size:u.getShortU16Encoder()})],["lifetimeToken",o.getStringEncoder({encoding:o.getBase58Encoder(),size:32})],["instructions",c.getArrayEncoder((R||(R=s.mapEncoder(c.getStructEncoder([["programAddressIndex",u.getU8Encoder()],["accountIndices",c.getArrayEncoder(u.getU8Encoder(),{size:u.getShortU16Encoder()})],["data",c.getBytesEncoder({size:u.getShortU16Encoder()})]]),(e=>void 0!==e.accountIndices&&void 0!==e.data?e:{...e,accountIndices:e.accountIndices??[],data:e.data??new Uint8Array(0)}))),R),{size:u.getShortU16Encoder()})]]}function q(){return s.createEncoder({getSizeFromValue:e=>"legacy"===e.version?H().getSizeFromValue(e):G().getSizeFromValue(e),write:(e,t,n)=>"legacy"===e.version?H().write(e,t,n):G().write(e,t,n)})}function Y(){return s.mapDecoder(c.getStructDecoder([["version",s.createDecoder({maxSize:1,read:(e,t)=>{const n=e[t];return 0==(n&V)?["legacy",t]:[n^V,t+1]}})],["header",c.getStructDecoder([["numSignerAccounts",K()],["numReadonlySignerAccounts",K()],["numReadonlyNonSignerAccounts",K()]])],["staticAccounts",c.getArrayDecoder(i.getAddressDecoder(),{size:u.getShortU16Decoder()})],["lifetimeToken",o.getStringDecoder({encoding:o.getBase58Decoder(),size:32})],["instructions",c.getArrayDecoder((P||(P=s.mapDecoder(c.getStructDecoder([["programAddressIndex",u.getU8Decoder()],["accountIndices",c.getArrayDecoder(u.getU8Decoder(),{size:u.getShortU16Decoder()})],["data",c.getBytesDecoder({size:u.getShortU16Decoder()})]]),(e=>{if(e.accountIndices.length&&e.data.byteLength)return e;const{accountIndices:t,data:n,...r}=e;return{...r,...t.length?{accountIndices:t}:null,...n.byteLength?{data:n}:null}}))),P),{size:u.getShortU16Decoder()})],["addressTableLookups",c.getArrayDecoder((B||(B=c.getStructDecoder([["lookupTableAddress",i.getAddressDecoder()],["writableIndices",c.getArrayDecoder(u.getU8Decoder(),{size:u.getShortU16Decoder()})],["readableIndices",c.getArrayDecoder(u.getU8Decoder(),{size:u.getShortU16Decoder()})]])),B),{size:u.getShortU16Decoder()})]]),(({addressTableLookups:e,...t})=>"legacy"!==t.version&&e?.length?{...t,addressTableLookups:e}:t))}function X(e){const t=M(e);let n;if("signatures"in e){n=[];for(let r=0;r<t.header.numSignerAccounts;r++)n[r]=e.signatures[t.staticAccounts[r]]??new Uint8Array(Array(64).fill(0))}else n=Array(t.header.numSignerAccounts).fill(new Uint8Array(Array(64).fill(0)));return{compiledMessage:t,signatures:n}}function Z(){return c.getStructDecoder([["signatures",c.getArrayDecoder(c.getBytesDecoder({size:64}),{size:u.getShortU16Decoder()})],["compiledMessage",Y()]])}function Q(){return s.mapEncoder(c.getStructEncoder([["signatures",c.getArrayEncoder(c.getBytesEncoder({size:64}),{size:u.getShortU16Encoder()})],["compiledMessage",q()]]),X)}function ee(e){return s.mapDecoder(Z(),(t=>z(t,e)))}async function te(e,t){const n=M(t),r="signatures"in t?{...t.signatures}:{},o=q().encode(n),a=await Promise.all(e.map((e=>Promise.all([i.getAddressFromPublicKey(e.publicKey),l.signBytes(e.privateKey,o)]))));for(const[e,t]of a)r[e]=t;const s={...t,signatures:r};return Object.freeze(s),s}function ne(e){const t=e.instructions.flatMap((e=>e.accounts?.filter((e=>y(e.role)))??[])).map((e=>e.address)),n=new Set([e.feePayer,...t]),r=[];if(n.forEach((t=>{e.signatures[t]||r.push(t)})),r.length>0)throw new d.SolanaError(d.SOLANA_ERROR__TRANSACTION_MISSING_SIGNATURES,{addresses:r})}t.appendTransactionInstruction=k,t.assertIsDurableNonceTransaction=function(e){if(!x(e))throw new Error("Transaction is not a durable nonce transaction")},t.assertIsTransactionWithBlockhashLifetime=function(e){if(!function(e){if(!("lifetimeConstraint"in e)||"string"!=typeof e.lifetimeConstraint.blockhash||"bigint"!=typeof e.lifetimeConstraint.lastValidBlockHeight)return!1;try{return function(e){r||(r=o.getBase58Encoder());try{if(e.length<32||e.length>44)throw new Error("Expected input string to decode to a byte array of length 32.");const t=r.encode(e).byteLength;if(32!==t)throw new Error(`Expected input string to decode to a byte array of length 32. Actual length: ${t}`)}catch(t){throw new Error(`\`${e}\` is not a blockhash`,{cause:t})}}(e.lifetimeConstraint.blockhash),!0}catch{return!1}}(e))throw new Error("Transaction does not have a blockhash lifetime")},t.assertTransactionIsFullySigned=ne,t.compileMessage=M,t.createTransaction=m,t.decompileTransaction=z,t.getBase64EncodedWireTransaction=function(e){const t=Q().encode(e);return o.getBase64Decoder().decode(t)},t.getCompiledMessageCodec=function(){return s.combineCodec(q(),Y())},t.getCompiledMessageDecoder=Y,t.getCompiledMessageEncoder=q,t.getCompiledTransactionDecoder=Z,t.getSignatureFromTransaction=function(e){W||(W=o.getBase58Decoder());const t=e.signatures[e.feePayer];if(!t)throw new d.SolanaError(d.SOLANA_ERROR__TRANSACTION_SIGNATURE_NOT_COMPUTABLE);return W.decode(t)},t.getTransactionCodec=function(e){return s.combineCodec(Q(),ee(e))},t.getTransactionDecoder=ee,t.getTransactionEncoder=Q,t.isAdvanceNonceAccountInstruction=v,t.partiallySignTransaction=te,t.prependTransactionInstruction=function(e,t){const n={...f(t),instructions:[e,...t.instructions]};return Object.freeze(n),n},t.setTransactionFeePayer=I,t.setTransactionLifetimeUsingBlockhash=g,t.setTransactionLifetimeUsingDurableNonce=T,t.signTransaction=async function(e,t){const n=await te(e,t);return ne(n),Object.freeze(n),n}},744:()=>{"use strict";var e=(()=>!1)(),t=2n**255n-19n,n=2n**252n+27742317777372353535851937790883648493n,r=0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51an,o=0x6666666666666666666666666666666666666666666666666666666666666658n,i={a:-1n,d:37095705934669439343138083508754565189542113879843219016388785533085940283555n,p:t,n,h:8,Gx:r,Gy:o},a=(e="")=>{throw new Error(e)},s=e=>"string"==typeof e,c=(e,t)=>!(e instanceof Uint8Array)||"number"==typeof t&&t>0&&e.length!==t?a("Uint8Array expected"):e,u=e=>new Uint8Array(e),d=(e,t)=>c(s(e)?S(e):u(e),t),l=(e,n=t)=>{let r=e%n;return r>=0n?r:n+r},f=e=>e instanceof m?e:a("Point expected"),g=void 0,m=class e{constructor(e,t,n,r){this.ex=e,this.ey=t,this.ez=n,this.et=r}static fromAffine(t){return new e(t.x,t.y,1n,l(t.x*t.y))}static fromHex(n,r=!0){const{d:o}=i,s=(n=d(n,32)).slice();s[31]=-129&n[31];const c=A(s);0n===c||(!r||0n<c&&c<t||a("bad y coord 1"),r||0n<c&&c<2n**256n||a("bad y coord 2"));const u=l(c*c),f=l(u-1n),g=l(o*u+1n);let{isValid:m,value:p}=k(f,g);m||a("bad y coordinate 3");const h=1n===(1n&p);return 0!=(128&n[31])!==h&&(p=l(-p)),new e(p,c,1n,l(p*c))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}equals(e){const{ex:t,ey:n,ez:r}=this,{ex:o,ey:i,ez:a}=f(e),s=l(t*a),c=l(o*r),u=l(n*a),d=l(i*r);return s===c&&u===d}is0(){return this.equals(y)}negate(){return new e(l(-this.ex),this.ey,this.ez,l(-this.et))}double(){const{ex:t,ey:n,ez:r}=this,{a:o}=i,a=l(t*t),s=l(n*n),c=l(2n*l(r*r)),u=l(o*a),d=t+n,f=l(l(d*d)-a-s),g=u+s,m=g-c,p=u-s,h=l(f*m),y=l(g*p),b=l(f*p),w=l(m*g);return new e(h,y,w,b)}add(t){const{ex:n,ey:r,ez:o,et:a}=this,{ex:s,ey:c,ez:u,et:d}=f(t),{a:g,d:m}=i,p=l(n*s),h=l(r*c),y=l(a*m*d),b=l(o*u),w=l((n+r)*(s+c)-p-h),S=l(b-y),E=l(b+y),A=l(h-g*p),v=l(w*S),x=l(E*A),T=l(w*A),I=l(S*E);return new e(v,x,I,T)}mul(e,t=!0){if(0n===e)return!0===t?a("cannot multiply by 0"):y;if("bigint"==typeof e&&0n<e&&e<n||a("invalid scalar, must be < L"),!t&&this.is0()||1n===e)return this;if(this.equals(h))return j(e).p;let r=y,o=h;for(let n=this;e>0n;n=n.double(),e>>=1n)1n&e?r=r.add(n):t&&(o=o.add(n));return r}multiply(e){return this.mul(e)}clearCofactor(){return this.mul(BigInt(i.h),!1)}isSmallOrder(){return this.clearCofactor().is0()}isTorsionFree(){let e=this.mul(n/2n,!1).double();return n%2n&&(e=e.add(this)),e.is0()}toAffine(){const{ex:e,ey:t,ez:n}=this;if(this.is0())return{x:0n,y:0n};const r=x(n);return 1n!==l(n*r)&&a("invalid inverse"),{x:l(e*r),y:l(t*r)}}toRawBytes(){const{x:e,y:t}=this.toAffine(),n=E(t);return n[31]|=1n&e?128:0,n}toHex(){return w(this.toRawBytes())}};m.BASE=new m(r,o,1n,l(r*o)),m.ZERO=new m(0n,1n,1n,0n);var p,{BASE:h,ZERO:y}=m,b=(e,t)=>e.toString(16).padStart(t,"0"),w=e=>Array.from(e).map((e=>b(e,2))).join(""),S=e=>{const t=e.length;(!s(e)||t%2)&&a("hex invalid 1");const n=u(t/2);for(let t=0;t<n.length;t++){const r=2*t,o=e.slice(r,r+2),i=Number.parseInt(o,16);(Number.isNaN(i)||i<0)&&a("hex invalid 2"),n[t]=i}return n},E=e=>S(b(e,64)).reverse(),A=e=>BigInt("0x"+w(u(c(e)).reverse())),v=(...e)=>{const t=u(e.reduce(((e,t)=>e+c(t).length),0));let n=0;return e.forEach((e=>{t.set(e,n),n+=e.length})),t},x=(e,n=t)=>{(0n===e||n<=0n)&&a("no inverse n="+e+" mod="+n);let r=l(e,n),o=n,i=0n,s=1n;for(;0n!==r;){const e=o%r,t=i-s*(o/r);o=r,r=e,i=s,s=t}return 1n===o?l(i,n):a("no inverse")},T=(e,n)=>{let r=e;for(;n-- >0n;)r*=r,r%=t;return r},I=19681161376707505956807079304988542015446066515923890162744021073123829784752n,k=(e,n)=>{const r=l(n*n*n),o=(e=>{const n=e*e%t*e%t,r=T(n,2n)*n%t,o=T(r,1n)*e%t,i=T(o,5n)*o%t,a=T(i,10n)*i%t,s=T(a,20n)*a%t,c=T(s,40n)*s%t,u=T(c,80n)*c%t,d=T(u,80n)*c%t,l=T(d,10n)*i%t;return{pow_p_5_8:T(l,2n)*e%t,b2:n}})(e*l(r*r*n)).pow_p_5_8;let i=l(e*r*o);const a=l(n*i*i),s=i,c=l(i*I),u=a===e,d=a===l(-e),f=a===l(-e*I);return u&&(i=s),(d||f)&&(i=c),1n===(1n&l(i))&&(i=l(-i)),{isValid:u||d,value:i}},z=e=>l(A(e),n),C=(...e)=>P.sha512Async(...e),O=(...e)=>"function"==typeof p?p(...e):a("etc.sha512Sync not set"),B=e=>{const t=e.slice(0,32);t[0]&=248,t[31]&=127,t[31]|=64;const n=e.slice(32,64),r=z(t),o=h.mul(r),i=o.toRawBytes();return{head:t,prefix:n,scalar:r,point:o,pointBytes:i}},N=e=>C(d(e,32)).then(B);function D(e,t){return e?C(t.hashable).then(t.finish):t.finish(O(t.hashable))}var R=()=>"object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0,P={bytesToHex:w,hexToBytes:S,concatBytes:v,mod:l,invert:x,randomBytes:e=>{const t=R();return t||a("crypto.getRandomValues must be defined"),t.getRandomValues(u(e))},sha512Async:async(...e)=>{const t=R();t||a("crypto.subtle or etc.sha512Async must be defined");const n=v(...e);return u(await t.subtle.digest("SHA-512",n.buffer))},sha512Sync:void 0};Object.defineProperties(P,{sha512Sync:{configurable:!1,get:()=>p,set(e){p||(p=e)}}});var _,U,L=()=>P.randomBytes(32),j=e=>{const t=g||(g=(()=>{const e=[];let t=h,n=t;for(let r=0;r<33;r++){n=t,e.push(n);for(let r=1;r<128;r++)n=n.add(t),e.push(n);t=n.double()}return e})()),n=(e,t)=>{let n=t.negate();return e?n:t};let r=y,o=h;const i=BigInt(255),a=BigInt(8);for(let s=0;s<33;s++){const c=128*s;let u=Number(e&i);e>>=a,u>128&&(u-=256,e+=1n);const d=c,l=c+Math.abs(u)-1,f=s%2!=0,g=u<0;0===u?o=o.add(n(f,t[d])):r=r.add(n(g,t[l]))}return{p:r,f:o}},F=new Set(["decrypt","deriveBits","deriveKey","encrypt","unwrapKey","wrapKey"]),M=[48,46,2,1,0,48,5,6,3,43,101,112,4,34,4,32];function $(e){return e instanceof Uint8Array?e:new Uint8Array(ArrayBuffer.isView(e)?e.buffer:e)}function K(e){const t=_?.get(e);if(void 0===t)throw new Error("Could not find secret key material associated with this `CryptoKey`");return t}async function W(e){const t=U||=new WeakMap,n=t.get(e);if(n)return n;const r=await(o=K(e),N(o).then((e=>e.pointBytes)));var o;return t.set(e,r),r}function V(e){return!!_?.has(e)||!!U?.has(e)}if(globalThis.isSecureContext){const t=globalThis.crypto||={},r=t.subtle||={},o=r.exportKey;r.exportKey=async(...e)=>{const[t,n]=e;if(V(n))return await async function(e,t){if(!1===t.extractable)throw new DOMException("key is not extractable","InvalidAccessException");switch(e){case"raw":if("public"!==t.type)throw new DOMException(`Unable to export a raw Ed25519 ${t.type} key`,"InvalidAccessError");return await W(t);case"pkcs8":{if("private"!==t.type)throw new DOMException(`Unable to export a pkcs8 Ed25519 ${t.type} key`,"InvalidAccessError");const e=K(t);return new Uint8Array([...M,...e])}default:throw new Error(`Exporting polyfilled Ed25519 keys in the "${e}" format is unimplemented`)}}(...e);if(o)return await o.apply(r,e);throw new TypeError("No native `exportKey` function exists to handle this call")};const i=r.generateKey;let a;r.generateKey=async(...t)=>{const[n]=t;if("Ed25519"!==n){if(i)return await i.apply(r,t);throw new TypeError("No native `generateKey` function exists to handle this call")}let o;if(void 0===a&&(a=new Promise((n=>{i?i.apply(r,t).then((t=>{e&&console.warn("`@solana/webcrypto-ed25519-polyfill` was included in an environment that supports Ed25519 key manipulation natively. Falling back to the native implementation. Consider including this polyfill only in environments where Ed25519 is not supported."),r.generateKey!==i&&(r.generateKey=i),o=t,n(a=!0)})).catch((()=>{n(a=!1)})):n(a=!1)}))),"boolean"==typeof a?a:await a){if(o)return o;if(i)return await i.apply(r,t);throw new TypeError("No native `generateKey` function exists to handle this call")}{const[e,n,r]=t;return function(e,t){return function(e,t,n){const r=function(e,t){if(0===t.length)throw new DOMException("Usages cannot be empty when creating a key.","SyntaxError");if(t.some((e=>F.has(e))))throw new DOMException("Unsupported key usage for an Ed25519 key.","SyntaxError");const n={[Symbol.toStringTag]:"CryptoKey",algorithm:Object.freeze({name:"Ed25519"})},r={...n,extractable:e,type:"private",usages:Object.freeze(t.filter((e=>"sign"===e)))},o={...n,extractable:!0,type:"public",usages:Object.freeze(t.filter((e=>"verify"===e)))};return Object.freeze({privateKey:Object.freeze(r),publicKey:Object.freeze(o)})}(t,n),o=_||=new WeakMap;return o.set(r.privateKey,e),o.set(r.publicKey,e),r}(L(),e,t)}(n,r)}};const s=r.sign;r.sign=async(...e)=>{const[t,o]=e;if(V(o)){const[t,...r]=e;return await async function(e,t){if("private"!==e.type||!e.usages.includes("sign"))throw new DOMException("Unable to use this key to sign","InvalidAccessError");const r=K(e),o=$(t);return await(async(e,t)=>{const r=d(e),o=await N(t);return D(!0,((e,t,r)=>{const{pointBytes:o,scalar:i}=e,a=z(t),s=h.mul(a).toRawBytes();return{hashable:v(s,o,r),finish:e=>{const t=l(a+z(e)*i,n);return c(v(s,E(t)),64)}}})(o,await C(o.prefix,r),r))})(o,r)}(...r)}if(s)return await s.apply(r,e);throw new TypeError("No native `sign` function exists to handle this call")};const u=r.verify;r.verify=async(...e)=>{const[t,n]=e;if(V(n)){const[t,...n]=e;return await async function(e,t,n){if("public"!==e.type||!e.usages.includes("verify"))throw new DOMException("Unable to use this key to verify","InvalidAccessError");const r=await W(e);try{return await(async(e,t,n)=>D(!0,((e,t,n)=>{t=d(t),e=d(e,64);const r=m.fromHex(n,!1),o=m.fromHex(e.slice(0,32),!1),i=A(e.slice(32,64)),a=h.mul(i,!1);return{hashable:v(o.toRawBytes(),r.toRawBytes(),t),finish:e=>{const t=z(e);return o.add(r.mul(t,!1)).add(a.negate()).clearCofactor().is0()}}})(e,t,n)))($(t),$(n),r)}catch{return!1}}(...n)}if(u)return await u.apply(r,e);throw new TypeError("No native `verify` function exists to handle this call")};const f=r.importKey;let g;r.importKey=async(...t)=>{const[n,o,i]=t;if("Ed25519"!==i){if(f)return await f.apply(r,t);throw new TypeError("No native `importKey` function exists to handle this call")}let a;if(void 0===g&&(g=new Promise((n=>{f?f.apply(r,t).then((t=>{e&&console.warn("`@solana/webcrypto-ed25519-polyfill` was included in an environment that supports Ed25519 key manipulation natively. Falling back to the native implementation. Consider including this polyfill only in environments where Ed25519 is not supported."),r.importKey!==f&&(r.importKey=f),a=t,n(g=!0)})).catch((()=>{n(g=!1)})):n(g=!1)}))),"boolean"==typeof f?g:await g){if(a)return a;if(f)return await f.apply(r,t);throw new TypeError("No native `importKey` function exists to handle this call")}{const[e,r,i,a,s]=t;return function(e,t,n,r){const o=$(t);if("raw"===e){if(r.some((e=>"sign"===e||F.has(e))))throw new DOMException("Unsupported key usage for a Ed25519 key","SyntaxError");if(32!==o.length)throw new DOMException("Ed25519 raw keys must be exactly 32-bytes","DataError");const e={[Symbol.toStringTag]:"CryptoKey",algorithm:Object.freeze({name:"Ed25519"}),extractable:n,type:"public",usages:Object.freeze(r.filter((e=>"verify"===e)))};return(U||=new WeakMap).set(e,o),e}if("pkcs8"===e){if(r.some((e=>"verify"===e||F.has(e))))throw new DOMException("Unsupported key usage for a Ed25519 key","SyntaxError");if(48!==o.length)throw new DOMException("Invalid keyData","DataError");if(!o.slice(0,16).every(((e,t)=>e===M[t])))throw new DOMException("Invalid keyData","DataError");const e=o.slice(16),t={[Symbol.toStringTag]:"CryptoKey",algorithm:Object.freeze({name:"Ed25519"}),extractable:n,type:"private",usages:Object.freeze(r.filter((e=>"sign"===e)))};return(_||=new WeakMap).set(t,e),t}throw new Error(`Importing Ed25519 keys in the "${e}" format is unimplemented`)}(n,o,a,s)}}}},224:(e,t,n)=>{"use strict";var r=n(932),o=n(868),i=n(480),a=n(364),s=n(536),c=n(964),u=n(156),d=n(48),l=n(976),f=n(672),g=n(296),m=n(324),p=n(808),h=n(176),y=n(916);function b(e){return e&&e.__esModule?e:{default:e}}var w=b(h),S=(()=>!1)();async function E(e,t,n){const{abortSignal:r,commitment:o,getRecentSignatureConfirmationPromise:i}=t;r?.throwIfAborted();const a=new AbortController;if(r){const e=()=>{a.abort()};r.addEventListener("abort",e,{signal:a.signal})}try{const r=n({...t,abortSignal:a.signal});return await Promise.race([i({abortSignal:a.signal,commitment:o,signature:e}),...r])}finally{a.abort()}}function A(e,t){return async function({abortSignal:n,commitment:r,signature:o}){const i=new AbortController;n.addEventListener("abort",(function(){i.abort()}),{signal:i.signal});const a=await t.signatureNotifications(o,{commitment:r}).subscribe({abortSignal:i.signal}),s=(async()=>{for await(const e of a){if(e.value.err)throw new Error(`The transaction with signature \`${o}\` failed.`,{cause:e.value.err});return}})(),c=(async()=>{const{value:t}=await e.getSignatureStatuses([o]).send({abortSignal:i.signal}),n=t[0];n&&n.confirmationStatus&&l.commitmentComparator(n.confirmationStatus,r)>=0||await new Promise((()=>{}))})();try{return await Promise.race([s,c])}finally{i.abort()}}}async function v({abortSignal:e,commitment:t}){return await new Promise(((n,r)=>{e.addEventListener("abort",(e=>{clearTimeout(a);const t=new DOMException(e.target.reason,"AbortError");r(t)}));const o="processed"===t?3e4:6e4,i=performance.now(),a=setTimeout((()=>{const e=performance.now()-i;r(new DOMException(`Timeout elapsed after ${e} ms`,"TimeoutError"))}),o)}))}async function x({abortSignal:e,commitment:t,confirmSignatureOnlyTransaction:n,lamports:r,recipientAddress:o,rpc:i}){const a=await i.requestAirdrop(o,r,{commitment:t}).send({abortSignal:e});return await n({abortSignal:e,commitment:t,signature:a}),a}var T=void 0;function I(e,t,n){let r="";if("number"==typeof t[0]){const e=t[0]+1,n=e%10,o=e%100;r=1==n&&11!=o?e+"st":2==n&&12!=o?e+"nd":3==n&&13!=o?e+"rd":e+"th"}else r=`\`${t[0].toString()}\``;const o=t.length>1?t.slice(1).map((e=>"number"==typeof e?`[${e}]`:e)).join("."):void 0,i=new y.SolanaError(y.SOLANA_ERROR__RPC_INTEGER_OVERFLOW,{argumentLabel:r,keyPath:t,methodName:e,optionalPathLabel:o?` at path \`${o}\``:"",value:n,...void 0!==o?{path:o}:void 0});return"captureStackTrace"in Error&&"function"==typeof Error.captureStackTrace&&Error.captureStackTrace(i,I),i}var k={defaultCommitment:"confirmed",onIntegerOverflow(e,t,n){throw I(e,t,n)}};function z({getAbortSignalFromInputArgs:e,getCacheEntryMissingError:t,getCacheKeyFromInputArgs:n,onCacheHit:r,onCreateIterable:o}){const i=new Map;return async(...a)=>{const s=n(...a),c=e(...a);if(void 0===s)return await o(c,...a);const u=()=>{i.delete(s),c.removeEventListener("abort",d)},d=()=>{const e=function(e){const n=i.get(e);if(!n)throw t(e);return n}(s);!0!==e.purgeScheduled&&(e.purgeScheduled=!0,globalThis.queueMicrotask((()=>{e.purgeScheduled=!1,0===e.referenceCount&&(e.abortController.abort(),u())}))),e.referenceCount--};c.addEventListener("abort",d);try{const e=i.get(s);if(e){e.referenceCount++;const t=e.iterable,n="then"in t?await t:t;return await r(n,...a),n}{const e=new AbortController,t=o(e.signal,...a),n={abortController:e,iterable:t,purgeScheduled:!1,referenceCount:1};i.set(s,n);const r=await t;return l=r,f=u,(async()=>{try{for await(const e of l);}catch{}finally{f()}})(),n.iterable=r,r}}catch(e){throw u(),e}var l,f}}var C=Symbol(S?"This symbol is thrown from a subscription's iterator when the subscription is explicitly aborted by the user":void 0);function O(e){return function(e){return null!=e&&"object"==typeof e&&!Array.isArray(e)&&"jsonrpc"in e&&"2.0"===e.jsonrpc&&"method"in e&&"string"==typeof e.method&&"params"in e}(e)?w.default([e.method,e.params]):void 0}function B(e){const t={};for(const n in e)t[n.toLowerCase()]=e[n];return t}var N={jsonrpc:"2.0",method:"ping"},D=Symbol(S?"Cache key to use when there is no connection sharding strategy":void 0);function R({rpc:e,rpcSubscriptions:t}){return async function({abortSignal:n,commitment:r,lastValidBlockHeight:o}){const i=new AbortController;async function a(){const{absoluteSlot:t,blockHeight:n}=await e.getEpochInfo({commitment:r}).send({abortSignal:i.signal});return{blockHeight:n,differenceBetweenSlotHeightAndBlockHeight:t-n}}n.addEventListener("abort",(()=>{i.abort()}),{signal:i.signal});try{const[e,{blockHeight:n,differenceBetweenSlotHeightAndBlockHeight:r}]=await Promise.all([t.slotNotifications().subscribe({abortSignal:i.signal}),a()]);if(n<=o){let t=r;for await(const n of e){const{slot:e}=n;if(e-t>o){const{blockHeight:e,differenceBetweenSlotHeightAndBlockHeight:n}=await a();if(e>o)break;t=n}}}throw new Error("The network has progressed past the last block for which this transaction could have been committed.")}finally{i.abort()}}}var P=40;function _(e,t){return async function({abortSignal:n,commitment:r,currentNonceValue:o,nonceAccountAddress:a}){const s=new AbortController;n.addEventListener("abort",(function(){s.abort()}),{signal:s.signal});const c=await t.accountNotifications(a,{commitment:r,encoding:"base64"}).subscribe({abortSignal:s.signal}),u=i.getBase58Decoder(),d=i.getBase64Encoder();function l([e]){const t=d.encode(e).slice(P,P+32);return u.decode(t)}const f=(async()=>{for await(const e of c){const t=l(e.value.data);if(t!==o)throw new Error(`The nonce \`${o}\` is no longer valid. It has advanced to \`${t}\`.`)}})(),g=(async()=>{const{value:t}=await e.getAccountInfo(a,{commitment:r,dataSlice:{length:32,offset:P},encoding:"base58"}).send({abortSignal:s.signal});if(!t)throw new Error(`No nonce account could be found at address \`${a}\`.`);const n=t.data[0];if(n!==o)throw new Error(`The nonce \`${o}\` is no longer valid. It has advanced to \`${n}\`.`);await new Promise((()=>{}))})();try{return await Promise.race([f,g])}finally{s.abort()}}}function U({rpc:e,rpcSubscriptions:t}){const n=_(e,t),r=A(e,t);return async function(e){await j({...e,getNonceInvalidationPromise:n,getRecentSignatureConfirmationPromise:r})}}function L({rpc:e,rpcSubscriptions:t}){const n=R({rpc:e,rpcSubscriptions:t}),r=A(e,t);return async function(e){await F({...e,getBlockHeightExceedencePromise:n,getRecentSignatureConfirmationPromise:r})}}async function j(e){await E(g.getSignatureFromTransaction(e.transaction),e,(function({abortSignal:e,commitment:t,getNonceInvalidationPromise:n,transaction:r}){return[n({abortSignal:e,commitment:t,currentNonceValue:r.lifetimeConstraint.nonce,nonceAccountAddress:r.instructions[0].accounts[0].address})]}))}async function F(e){await E(g.getSignatureFromTransaction(e.transaction),e,(function({abortSignal:e,commitment:t,getBlockHeightExceedencePromise:n,transaction:r}){return[n({abortSignal:e,commitment:t,lastValidBlockHeight:r.lifetimeConstraint.lastValidBlockHeight})]}))}function M(e,t){return!t?.preflightCommitment&&l.commitmentComparator(e,"finalized")<0?{...t,preflightCommitment:e}:t}async function $({abortSignal:e,commitment:t,rpc:n,transaction:r,...o}){const i=g.getBase64EncodedWireTransaction(r);return await n.sendTransaction(i,{...M(t,o),encoding:"base64"}).send({abortSignal:e})}async function K({abortSignal:e,commitment:t,confirmDurableNonceTransaction:n,rpc:r,transaction:o,...i}){const a=await $({...i,abortSignal:e,commitment:t,rpc:r,transaction:o});return await n({abortSignal:e,commitment:t,transaction:o}),a}async function W({abortSignal:e,commitment:t,confirmRecentTransaction:n,rpc:r,transaction:o,...i}){const a=await $({...i,abortSignal:e,commitment:t,rpc:r,transaction:o});return await n({abortSignal:e,commitment:t,transaction:o}),a}t.createBlockHeightExceedencePromiseFactory=R,t.createDefaultAirdropRequester=function({rpc:e,rpcSubscriptions:t}){const n=function({rpc:e,rpcSubscriptions:t}){const n=A(e,t);return async function(e){await async function(e){await E(e.signature,e,(function({abortSignal:e,commitment:t,getTimeoutPromise:n}){return[n({abortSignal:e,commitment:t})]}))}({...e,getRecentSignatureConfirmationPromise:n,getTimeoutPromise:v})}}({rpc:e,rpcSubscriptions:t});return async function(t){return await x({...t,confirmSignatureOnlyTransaction:n,rpc:e})}},t.createDefaultDurableNonceTransactionConfirmer=U,t.createDefaultDurableNonceTransactionSender=function({rpc:e,rpcSubscriptions:t}){const n=U({rpc:e,rpcSubscriptions:t});return async function(t,r){await K({...r,confirmDurableNonceTransaction:n,rpc:e,transaction:t})}},t.createDefaultRecentTransactionConfirmer=L,t.createDefaultRpcSubscriptionsTransport=function(e){const{getShard:t,intervalMs:n,...r}=e;return a.pipe(p.createWebSocketTransport({...r,sendBufferHighWatermark:e.sendBufferHighWatermark??131072}),(e=>function({intervalMs:e,transport:t}){const n=new Map;return async(...r)=>{const o=await t(...r);let i;function a(){o.send_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(N)}function s(){clearInterval(i),i=setInterval(a,e)}if(!1===n.has(o)){let e,t;n.set(o,{[Symbol.asyncIterator]:o[Symbol.asyncIterator].bind(o),send_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:(...e)=>(s(),o.send_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(...e))}),(async()=>{try{for await(const e of o)s()}catch{}finally{n.delete(o),clearInterval(i),e&&globalThis.window.removeEventListener("offline",e),t&&globalThis.window.removeEventListener("online",t)}})(),globalThis.navigator.onLine&&s(),e=()=>{clearInterval(i)},t=()=>{a(),s()},globalThis.window.addEventListener("offline",e),globalThis.window.addEventListener("online",t)}return n.get(o)}}({intervalMs:n??5e3,transport:e})),(e=>function({getShard:e,transport:t}){return z({getAbortSignalFromInputArgs:({signal:e})=>e,getCacheEntryMissingError:e=>new Error(`Found no cache entry for connection with shard key \`${e?.toString()}\``),getCacheKeyFromInputArgs:({payload:t})=>e?e(t):D,onCacheHit:(e,{payload:t})=>e.send_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(t),onCreateIterable:(e,n)=>t({...n,signal:e})})}({getShard:t,transport:e})))},t.createDefaultRpcTransport=function(e){return a.pipe(p.createHttpTransport({...e,headers:{...e.headers?B(e.headers):void 0,"solana-client":"js/2.0.0-development"}}),(e=>function(e,t){let n;return async function(r){const{payload:o,signal:i}=r,a=t(o);if(void 0===a)return await e(r);if(n||(Promise.resolve().then((()=>{n=void 0})),n={}),null==n[a]){const t=new AbortController,o=(async()=>{try{return await e({...r,signal:t.signal})}catch(e){if(e&&"object"==typeof e&&"name"in e&&"AbortError"===e.name)return;throw e}})();n[a]={abortController:t,numConsumers:0,responsePromise:o}}const s=n[a];if(s.numConsumers++,i){const e=s.responsePromise;return await new Promise(((t,n)=>{const r=e=>{i.removeEventListener("abort",r),s.numConsumers-=1,0===s.numConsumers&&s.abortController.abort();const t=new DOMException(e.target.reason,"AbortError");n(t)};i.addEventListener("abort",r),e.then(t).finally((()=>{i.removeEventListener("abort",r)}))}))}return await s.responsePromise}}(e,O)))},t.createDefaultTransactionSender=function({rpc:e,rpcSubscriptions:t}){const n=L({rpc:e,rpcSubscriptions:t});return async function(t,r){await W({...r,confirmRecentTransaction:n,rpc:e,transaction:t})}},t.createNonceInvalidationPromiseFactory=_,t.createRecentSignatureConfirmationPromiseFactory=A,t.createSolanaRpc=function(e){const t=m.createSolanaRpcApi(k);return p.createJsonRpc({...e,api:t})},t.createSolanaRpcSubscriptions=function(e){return a.pipe(p.createJsonSubscriptionRpc({...e,api:m.createSolanaRpcSubscriptionsApi(k)}),(e=>function({getDeduplicationKey:e,rpcSubscriptions:t}){const n=new Map;return new Proxy(t,{defineProperty:()=>!1,deleteProperty:()=>!1,get(t,r,o){const i=Reflect.get(t,r,o);return"function"!=typeof i?i:function(...t){const o=e(r,t);if(void 0===o)return i(...t);if(n.has(o))return n.get(o);const a=z({getAbortSignalFromInputArgs:({abortSignal:e})=>e,getCacheEntryMissingError:e=>new Error(`Found no cache entry for subscription with deduplication key \`${e?.toString()}\``),getCacheKeyFromInputArgs:()=>o,async onCacheHit(e,t){},async onCreateIterable(e,r){const a=i(...t),s=await a.subscribe({...r,abortSignal:e});return function(e,t){(async()=>{try{for await(const t of e);}catch{}finally{n.delete(o)}})()}(s),s}}),s={async subscribe(...e){const t=await a(...e),{abortSignal:r}=e[0];let i;return{...t,async*[Symbol.asyncIterator](){i||=r.aborted?Promise.reject(C):new Promise(((e,t)=>{r.addEventListener("abort",(()=>{t(C)}))}));try{const e=t[Symbol.asyncIterator]();for(;;){const t=await Promise.race([e.next(),i]);if(t.done)return;yield t.value}}catch(e){if(e===C)return;throw n.delete(o),e}}}}};return n.set(o,s),s}}})}({getDeduplicationKey:(...e)=>w.default(e),rpcSubscriptions:e})))},t.createSolanaRpcSubscriptions_UNSTABLE=function(e){return p.createJsonSubscriptionRpc({...e,api:m.createSolanaRpcSubscriptionsApi_UNSTABLE(k)})},t.decodeTransaction=async function(e,t,n){const{lastValidBlockHeight:o,...i}=n??{};T||(T=g.getCompiledTransactionDecoder());const a=T.decode(e),{compiledMessage:s}=a,c=("addressTableLookups"in s&&void 0!==s.addressTableLookups&&s.addressTableLookups.length>0?s.addressTableLookups:[]).map((e=>e.lookupTableAddress)),u=c.length>0?await async function(e,t,n){const o=await r.fetchJsonParsedAccounts(t,e,n);return r.assertAccountsDecoded(o),r.assertAccountsExist(o),o.reduce(((e,t)=>({...e,[t.address]:t.data.addresses})),{})}(c,t,i):{};return g.decompileTransaction(a,{addressesByLookupTableAddress:u,lastValidBlockHeight:o})},t.requestAndConfirmAirdrop=x,t.sendAndConfirmDurableNonceTransaction=K,t.sendAndConfirmTransaction=W,t.waitForDurableNonceTransactionConfirmation=j,t.waitForRecentTransactionConfirmation=F,Object.keys(r).forEach((function(e){"default"===e||Object.prototype.hasOwnProperty.call(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:function(){return r[e]}})})),Object.keys(o).forEach((function(e){"default"===e||Object.prototype.hasOwnProperty.call(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:function(){return o[e]}})})),Object.keys(i).forEach((function(e){"default"===e||Object.prototype.hasOwnProperty.call(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:function(){return i[e]}})})),Object.keys(a).forEach((function(e){"default"===e||Object.prototype.hasOwnProperty.call(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:function(){return a[e]}})})),Object.keys(s).forEach((function(e){"default"===e||Object.prototype.hasOwnProperty.call(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:function(){return s[e]}})})),Object.keys(c).forEach((function(e){"default"===e||Object.prototype.hasOwnProperty.call(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:function(){return c[e]}})})),Object.keys(u).forEach((function(e){"default"===e||Object.prototype.hasOwnProperty.call(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:function(){return u[e]}})})),Object.keys(d).forEach((function(e){"default"===e||Object.prototype.hasOwnProperty.call(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:function(){return d[e]}})})),Object.keys(l).forEach((function(e){"default"===e||Object.prototype.hasOwnProperty.call(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:function(){return l[e]}})})),Object.keys(f).forEach((function(e){"default"===e||Object.prototype.hasOwnProperty.call(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:function(){return f[e]}})})),Object.keys(g).forEach((function(e){"default"===e||Object.prototype.hasOwnProperty.call(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:function(){return g[e]}})}))}},t={};!function n(r){var o=t[r];if(void 0!==o)return o.exports;var i=t[r]={exports:{}};return e[r].call(i.exports,i,i.exports,n),i.exports}(244)})();