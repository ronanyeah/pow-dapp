/*! For license information please see worker.js.LICENSE.txt */
(()=>{var e={393:e=>{var t=Object.prototype.toString,n=Object.keys||function(e){var t=[];for(var n in e)t.push(n);return t};function r(e,o){var i,s,a,c,d,u,l;if(!0===e)return"true";if(!1===e)return"false";switch(typeof e){case"object":if(null===e)return null;if(e.toJSON&&"function"==typeof e.toJSON)return r(e.toJSON(),o);if("[object Array]"===(l=t.call(e))){for(a="[",s=e.length-1,i=0;i<s;i++)a+=r(e[i],!0)+",";return s>-1&&(a+=r(e[i],!0)),a+"]"}if("[object Object]"===l){for(s=(c=n(e).sort()).length,a="",i=0;i<s;)void 0!==(u=r(e[d=c[i]],!1))&&(a&&(a+=","),a+=JSON.stringify(d)+":"+u),i++;return"{"+a+"}"}return JSON.stringify(e);case"function":case"undefined":return o?null:void 0;case"string":return JSON.stringify(e);default:return isFinite(e)?e:null}}e.exports=function(e){var t=r(e,!1);if(void 0!==t)return""+t}},827:function(e,t,n){"use strict";var r=this&&this.__awaiter||function(e,t,n,r){return new(n||(n=Promise))((function(o,i){function s(e){try{c(r.next(e))}catch(e){i(e)}}function a(e){try{c(r.throw(e))}catch(e){i(e)}}function c(e){var t;e.done?o(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(s,a)}c((r=r.apply(e,t||[])).next())}))},o=this&&this.__generator||function(e,t){var n,r,o,i,s={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return i={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function a(a){return function(c){return function(a){if(n)throw new TypeError("Generator is already executing.");for(;i&&(i=0,a[0]&&(s=0)),s;)try{if(n=1,r&&(o=2&a[0]?r.return:a[0]?r.throw||((o=r.return)&&o.call(r),0):r.next)&&!(o=o.call(r,a[1])).done)return o;switch(r=0,o&&(a=[2&a[0],o.value]),a[0]){case 0:case 1:o=a;break;case 4:return s.label++,{value:a[1],done:!1};case 5:s.label++,r=a[1],a=[0];continue;case 7:a=s.ops.pop(),s.trys.pop();continue;default:if(!((o=(o=s.trys).length>0&&o[o.length-1])||6!==a[0]&&2!==a[0])){s=0;continue}if(3===a[0]&&(!o||a[1]>o[0]&&a[1]<o[3])){s.label=a[1];break}if(6===a[0]&&s.label<o[1]){s.label=o[1],o=a;break}if(o&&s.label<o[2]){s.label=o[2],s.ops.push(a);break}o[2]&&s.ops.pop(),s.trys.pop();continue}a=t.call(e,s)}catch(e){a=[6,e],r=0}finally{n=o=0}if(5&a[0])throw a[1];return{value:a[0]?a[1]:void 0,done:!0}}([a,c])}}};Object.defineProperty(t,"__esModule",{value:!0}),n(181);var i=n(780);function s(e){return r(this,void 0,void 0,(function(){var t,n,r,i;return o(this,(function(o){switch(o.label){case 0:return[4,Promise.all([crypto.subtle.exportKey("raw",e.publicKey),crypto.subtle.exportKey("pkcs8",e.privateKey)])];case 1:return t=o.sent(),n=t[0],r=t[1],(i=new Uint8Array(64)).set(new Uint8Array(r).slice(16)),i.set(new Uint8Array(n),32),[2,i]}}))}))}onmessage=function(e){return r(void 0,void 0,void 0,(function(){var t,n,a,c;return o(this,(function(d){switch(d.label){case 0:return t=e.data,u=t.criteria,n="start"in u&&"end"in u?function(e){return e.startsWith(u.start)&&e.endsWith(u.end)}:"start"in u?function(e){return e.startsWith(u.start)}:function(e){return e.endsWith(u.end)},a=0,c=[],[4,Promise.all([r(void 0,void 0,void 0,(function(){var e;return o(this,(function(n){switch(n.label){case 0:if(!(a<t.count))return[3,5];n.label=1;case 1:return n.trys.push([1,3,,4]),[4,crypto.subtle.generateKey("Ed25519",!0,["sign","verify"])];case 2:return e=n.sent(),c.push(e),[3,4];case 3:return n.sent(),console.error("op1 fail"),[3,4];case 4:return a+=1,[3,0];case 5:return[2]}}))})),r(void 0,void 0,void 0,(function(){var e,r,d,u;return o(this,(function(o){switch(o.label){case 0:if(!(c.length>0||a<t.count))return[3,10];if(!(e=c.pop()))return[3,7];o.label=1;case 1:return o.trys.push([1,5,,6]),[4,(0,i.getAddressFromPublicKey)(e.publicKey)];case 2:return r=o.sent(),n(r)?(d=postMessage,u={},[4,s(e)]):[3,4];case 3:d.apply(void 0,[(u.match=o.sent(),u)]),o.label=4;case 4:return[3,6];case 5:return o.sent(),console.error("op2 fail"),[3,6];case 6:return[3,9];case 7:return[4,new Promise((function(e){return setTimeout((function(){return e(!0)}),0)}))];case 8:o.sent(),o.label=9;case 9:return[3,0];case 10:return[2]}}))}))])];case 1:return d.sent(),postMessage({exit:a}),[2]}var u}))})).catch((function(e){postMessage({error:e.message})}))}},2:(e,t,n)=>{"use strict";var r,o,i=n(433),s=n(738),a=n(929);function c(){return r||(r=s.getBase58Encoder()),r}function d(e){return!(e.length<32||e.length>44)&&32===c().encode(e).byteLength}function u(e){try{if(e.length<32||e.length>44)throw new Error("Expected input string to decode to a byte array of length 32.");const t=c().encode(e).byteLength;if(32!==t)throw new Error(`Expected input string to decode to a byte array of length 32. Actual length: ${t}`)}catch(t){throw new Error(`\`${e}\` is not a base-58 encoded address`,{cause:t})}}function l(e){return u(e),e}function f(e){return i.mapEncoder(s.getStringEncoder({description:e?.description??"Base58EncodedAddress",encoding:c(),size:32}),(e=>l(e)))}function g(e){return s.getStringDecoder({description:e?.description??"Base58EncodedAddress",encoding:(o||(o=s.getBase58Decoder()),o),size:32})}function p(e){return i.combineCodec(f(e),g(e))}var m=37095705934669439343138083508754565189542113879843219016388785533085940283555n,h=57896044618658097711785492504343953926634992332820282019728792003956564819949n,y=19681161376707505956807079304988542015446066515923890162744021073123829784752n;function b(e){const t=e%h;return t>=0n?t:h+t}function w(e,t){let n=e;for(;t-- >0n;)n*=n,n%=h;return n}async function S(e){if(32!==e.byteLength)return!1;const t=function(e){const t=e.reduce(((e,t,n)=>`${function(e){const t=e.toString(16);return 1===t.length?`0${t}`:t}(31===n?-129&t:t)}${e}`),"");return BigInt(`0x${t}`)}(e);return function(e,t){const n=b(e*e),r=function(e,t){const n=b(t*t*t),r=function(e){const t=e*e%h*e%h,n=w(t,2n)*t%h,r=w(n,1n)*e%h,o=w(r,5n)*r%h,i=w(o,10n)*o%h,s=w(i,20n)*i%h,a=w(s,40n)*s%h,c=w(a,80n)*a%h,d=w(c,80n)*a%h,u=w(d,10n)*o%h;return w(u,2n)*e%h}(e*b(n*n*t));let o=b(e*n*r);const i=b(t*o*o),s=o,a=b(o*y),c=i===e,d=i===b(-e),u=i===b(-e*y);return c&&(o=s),(d||u)&&(o=a),1n===(1n&b(o))&&(o=b(-o)),c||d?o:null}(b(n-1n),b(m*n+1n));return!(null===r||0n===r&&0!=(128&t))}(t,e[31])}var E=[80,114,111,103,114,97,109,68,101,114,105,118,101,100,65,100,100,114,101,115,115],x=class extends Error{};async function v({programAddress:e,seeds:t}){if(await a.assertDigestCapabilityIsAvailable(),t.length>16)throw new Error("A maximum of 16 seeds may be supplied when creating an address");let n;const r=t.reduce(((e,t,r)=>{const o="string"==typeof t?(n||(n=new TextEncoder)).encode(t):t;if(o.byteLength>32)throw new Error(`The seed at index ${r} exceeds the maximum length of 32 bytes`);return e.push(...o),e}),[]),o=p(),i=o.encode(e),s=await crypto.subtle.digest("SHA-256",new Uint8Array([...r,...i,...E])),c=new Uint8Array(s);if(await S(c))throw new x("Invalid seeds; point must fall off the Ed25519 curve");return o.decode(c)[0]}t.address=l,t.assertIsAddress=u,t.assertIsProgramDerivedAddress=function(e){if(!Array.isArray(e)||2!==e.length||"string"!=typeof e[0]||"number"!=typeof e[1])throw new Error("Expected given program derived address to have the following format: [Base58EncodedAddress, ProgramDerivedAddressBump].");if(e[1]<0||e[1]>255)throw new Error(`Expected program derived address bump to be in the range [0, 255], got: ${e[1]}.`);u(e[0])},t.createAddressWithSeed=async function({baseAddress:e,programAddress:t,seed:n}){const{encode:r,decode:o}=p(),i="string"==typeof n?(new TextEncoder).encode(n):n;if(i.byteLength>32)throw new Error("The seed exceeds the maximum length of 32 bytes");const s=r(t);if(s.length>=E.length&&s.slice(-E.length).every(((e,t)=>e===E[t])))throw new Error("programAddress cannot end with the PDA marker");const a=await crypto.subtle.digest("SHA-256",new Uint8Array([...r(e),...i,...s]));return o(new Uint8Array(a))[0]},t.getAddressCodec=p,t.getAddressComparator=function(){return new Intl.Collator("en",{caseFirst:"lower",ignorePunctuation:!1,localeMatcher:"best fit",numeric:!1,sensitivity:"variant",usage:"sort"}).compare},t.getAddressDecoder=g,t.getAddressEncoder=f,t.getAddressFromPublicKey=async function(e){if(await a.assertKeyExporterIsAvailable(),"public"!==e.type||"Ed25519"!==e.algorithm.name)throw new Error("The `CryptoKey` must be an `Ed25519` public key");const t=await crypto.subtle.exportKey("raw",e),[n]=g().decode(new Uint8Array(t));return n},t.getProgramDerivedAddress=async function({programAddress:e,seeds:t}){let n=255;for(;n>0;)try{return[await v({programAddress:e,seeds:[...t,new Uint8Array([n])]}),n]}catch(e){if(!(e instanceof x))throw e;n--}throw new Error("Unable to find a viable program address bump seed")},t.isAddress=d,t.isProgramDerivedAddress=function(e){return Array.isArray(e)&&2===e.length&&"string"==typeof e[0]&&"number"==typeof e[1]&&e[1]>=0&&e[1]<=255&&d(e[0])}},929:(e,t)=>{"use strict";function n(){if(!globalThis.isSecureContext)throw new Error("Cryptographic operations are only allowed in secure browser contexts. Read more here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts")}var r;t.assertDigestCapabilityIsAvailable=async function(){if(n(),void 0===globalThis.crypto||"function"!=typeof globalThis.crypto.subtle?.digest)throw new Error("No digest implementation could be found")},t.assertKeyExporterIsAvailable=async function(){if(n(),void 0===globalThis.crypto||"function"!=typeof globalThis.crypto.subtle?.exportKey)throw new Error("No key export implementation could be found")},t.assertKeyGenerationIsAvailable=async function(){if(n(),void 0===globalThis.crypto||"function"!=typeof globalThis.crypto.subtle?.generateKey)throw new Error("No key generation implementation could be found");if(!await async function(e){return void 0===r&&(r=new Promise((t=>{e.generateKey("Ed25519",!1,["sign","verify"]).catch((()=>{t(r=!1)})).then((()=>{t(r=!0)}))}))),"boolean"==typeof r?r:await r}(globalThis.crypto.subtle))throw new Error("This runtime does not support the generation of Ed25519 key pairs.\n\nInstall and import `@solana/webcrypto-ed25519-polyfill` before generating keys in environments that do not support Ed25519.\n\nFor a list of runtimes that currently support Ed25519 operations, visit https://github.com/WICG/webcrypto-secure-curves/issues/20")},t.assertSigningCapabilityIsAvailable=async function(){if(n(),void 0===globalThis.crypto||"function"!=typeof globalThis.crypto.subtle?.sign)throw new Error("No signing implementation could be found")},t.assertVerificationCapabilityIsAvailable=async function(){if(n(),void 0===globalThis.crypto||"function"!=typeof globalThis.crypto.subtle?.verify)throw new Error("No signature verification implementation could be found")}},433:(e,t)=>{"use strict";function n(e,t,n,r=0){const o=n.length-r;if(o<t)throw new Error(`Codec [${e}] expected ${t} bytes, got ${o}.`)}function r(e,t){if(null===e.fixedSize)throw new Error(t??"Expected a fixed-size codec, got a variable-size one.")}var o=e=>{const t=e.filter((e=>e.length));if(0===t.length)return e.length?e[0]:new Uint8Array;if(1===t.length)return t[0];const n=t.reduce(((e,t)=>e+t.length),0),r=new Uint8Array(n);let o=0;return t.forEach((e=>{r.set(e,o),o+=e.length})),r},i=(e,t)=>{if(e.length>=t)return e;const n=new Uint8Array(t).fill(0);return n.set(e),n},s=(e,t)=>i(e.length<=t?e:e.slice(0,t),t);function a(e,t,n){if(e.fixedSize!==t.fixedSize)throw new Error(`Encoder and decoder must have the same fixed size, got [${e.fixedSize}] and [${t.fixedSize}].`);if(e.maxSize!==t.maxSize)throw new Error(`Encoder and decoder must have the same max size, got [${e.maxSize}] and [${t.maxSize}].`);if(void 0===n&&e.description!==t.description)throw new Error(`Encoder and decoder must have the same description, got [${e.description}] and [${t.description}]. Pass a custom description as a third argument if you want to override the description and bypass this error.`);return{decode:t.decode,description:n??e.description,encode:e.encode,fixedSize:e.fixedSize,maxSize:e.maxSize}}function c(e,t,n){return{description:n??`fixed(${t}, ${e.description})`,fixedSize:t,maxSize:t}}function d(e,t,n){return{...c(e,t,n),encode:n=>s(e.encode(n),t)}}function u(e,t,r){return{...c(e,t,r),decode:(r,o=0)=>{n("fixCodec",t,r,o),(o>0||r.length>t)&&(r=r.slice(o,o+t)),null!==e.fixedSize&&(r=s(r,e.fixedSize));const[i]=e.decode(r,0);return[i,o+t]}}}function l(e,t){return{description:e.description,encode:n=>e.encode(t(n)),fixedSize:e.fixedSize,maxSize:e.maxSize}}function f(e,t){return{decode:(n,r=0)=>{const[o,i]=e.decode(n,r);return[t(o,n,r),i]},description:e.description,fixedSize:e.fixedSize,maxSize:e.maxSize}}function g(e){return r(e,"Cannot reverse a codec of variable size."),{...e,encode:t=>e.encode(t).reverse()}}function p(e){return r(e,"Cannot reverse a codec of variable size."),{...e,decode:(t,n=0)=>{const r=n+e.fixedSize;if(0===n&&t.length===r)return e.decode(t.reverse(),n);const i=o([...0===n?[]:[t.slice(0,n)],t.slice(n,r).reverse(),...t.length===r?[]:[t.slice(r)]]);return e.decode(i,n)}}}t.assertByteArrayHasEnoughBytesForCodec=n,t.assertByteArrayIsNotEmptyForCodec=function(e,t,n=0){if(t.length-n<=0)throw new Error(`Codec [${e}] cannot decode empty byte arrays.`)},t.assertFixedSizeCodec=r,t.combineCodec=a,t.fixBytes=s,t.fixCodec=function(e,t,n){return a(d(e,t,n),u(e,t,n))},t.fixDecoder=u,t.fixEncoder=d,t.mapCodec=function(e,t,n){return{decode:n?f(e,n).decode:e.decode,description:e.description,encode:l(e,t).encode,fixedSize:e.fixedSize,maxSize:e.maxSize}},t.mapDecoder=f,t.mapEncoder=l,t.mergeBytes=o,t.padBytes=i,t.reverseCodec=function(e){return a(g(e),p(e))},t.reverseDecoder=p,t.reverseEncoder=g},149:(e,t,n)=>{"use strict";var r=n(433),o=n(638);function i(e){return e.reduce(((e,t)=>null===e||null===t?null:e+t),0)}function s(e,t,n,r){if("number"==typeof e)return[e,r];if("object"==typeof e)return e.decode(n,r);if("remainder"===e){const e=i(t);if(null===e)throw new Error('Codecs of "remainder" size must have fixed-size items.');const o=n.slice(r).length;if(o%e!=0)throw new Error(`The remainder of the byte array (${o} bytes) cannot be split into chunks of ${e} bytes. Codecs of "remainder" size must have a remainder that is a multiple of its item size. In other words, ${o} modulo ${e} should be equal to zero.`);return[o/e,r]}throw new Error(`Unrecognized array-like codec size: ${JSON.stringify(e)}`)}function a(e){return"object"==typeof e?e.description:`${e}`}function c(e,t){if("number"!=typeof e)return null;if(0===e)return 0;const n=i(t);return null===n?null:n*e}function d(e,t){return"object"==typeof e?e.encode(t):new Uint8Array}function u(e,t,n){if(t!==n)throw new Error(`Expected [${e}] to have ${t} items, got ${n}.`)}function l(e,t,n){if("remainder"===t&&null===e.fixedSize)throw new Error('Codecs of "remainder" size must have fixed-size items.');return{description:n??`array(${e.description}; ${a(t)})`,fixedSize:c(t,[e.fixedSize]),maxSize:c(t,[e.maxSize])}}function f(e,t={}){const n=t.size??o.getU32Encoder();return{...l(e,n,t.description),encode:t=>("number"==typeof n&&u("array",n,t.length),r.mergeBytes([d(n,t.length),...t.map((t=>e.encode(t)))]))}}function g(e,t={}){const n=t.size??o.getU32Decoder();return{...l(e,n,t.description),decode:(t,r=0)=>{if("object"==typeof n&&0===t.slice(r).length)return[[],r];const[o,i]=s(n,[e.fixedSize],t,r);r=i;const a=[];for(let n=0;n<o;n+=1){const[n,o]=e.decode(t,r);a.push(n),r=o}return[a,r]}}}var p=(e,t={})=>{const n="boolean"==typeof t?{backward:t}:t,r=n.backward??!1,o=r?"; backward":"";return{description:n.description??`bitArray(${e}${o})`,encode(t){const n=[];for(let o=0;o<e;o+=1){let e=0;for(let n=0;n<8;n+=1)e|=Number(t[8*o+n]??0)<<(r?n:7-n);r?n.unshift(e):n.push(e)}return new Uint8Array(n)},fixedSize:e,maxSize:e}},m=(e,t={})=>{const n="boolean"==typeof t?{backward:t}:t,o=n.backward??!1,i=o?"; backward":"";return{decode(t,n=0){r.assertByteArrayHasEnoughBytesForCodec("bitArray",e,t,n);const i=[];let s=t.slice(n,n+e);return s=o?s.reverse():s,s.forEach((e=>{for(let t=0;t<8;t+=1)o?(i.push(Boolean(1&e)),e>>=1):(i.push(Boolean(128&e)),e<<=1)})),[i,n+e]},description:n.description??`bitArray(${e}${i})`,fixedSize:e,maxSize:e}};function h(e={}){const t=e.size??o.getU8Encoder();return r.assertFixedSizeCodec(t,"Codec [bool] requires a fixed size."),{description:e.description??`bool(${t.description})`,encode:e=>t.encode(e?1:0),fixedSize:t.fixedSize,maxSize:t.fixedSize}}function y(e={}){const t=e.size??o.getU8Decoder();return r.assertFixedSizeCodec(t,"Codec [bool] requires a fixed size."),{decode:(e,n=0)=>{r.assertByteArrayIsNotEmptyForCodec("bool",e,n);const[o,i]=t.decode(e,n);return[1===o,i]},description:e.description??`bool(${t.description})`,fixedSize:t.fixedSize,maxSize:t.fixedSize}}function b(e={}){const t=e.size??"variable",n="object"==typeof t?t.description:`${t}`,o=e.description??`bytes(${n})`,i={description:o,encode:e=>e,fixedSize:null,maxSize:null};return"variable"===t?i:"number"==typeof t?r.fixEncoder(i,t,o):{...i,encode:e=>{const n=i.encode(e),o=t.encode(n.length);return r.mergeBytes([o,n])}}}function w(e={}){const t=e.size??"variable",n="object"==typeof t?t.description:`${t}`,o=e.description??`bytes(${n})`,i={decode:(e,t=0)=>{const n=e.slice(t);return[n,t+n.length]},description:o,fixedSize:null,maxSize:null};return"variable"===t?i:"number"==typeof t?r.fixDecoder(i,t,o):{...i,decode:(e,n=0)=>{r.assertByteArrayIsNotEmptyForCodec("bytes",e,n);const[o,s]=t.decode(e,n),a=Number(o);n=s;const c=e.slice(n,n+a);r.assertByteArrayHasEnoughBytesForCodec("bytes",a,c);const[d,u]=i.decode(c);return[d,n+=u]}}}function S(e,t,n){const r=e.map((([e,t])=>`${String(e)}${t?`: ${t.description}`:""}`)).join(", "),o=e.every(((e,t,n)=>e[1].fixedSize===n[0][1].fixedSize))?e[0][1].fixedSize:null,s=e.map((([,e])=>e.maxSize)).reduce(((e,t)=>null===e||null===t?null:Math.max(e,t)),0);return{description:n??`dataEnum(${r}; ${t.description})`,fixedSize:0===e.length?t.fixedSize:i([t.fixedSize,o]),maxSize:0===e.length?t.maxSize:i([t.maxSize,s])}}function E(e,t={}){const n=t.size??o.getU8Encoder();return{...S(e,n,t.description),encode:t=>{const o=e.findIndex((([e])=>t.__kind===e));if(o<0)throw new Error(`Invalid data enum variant. Expected one of [${e.map((([e])=>e)).join(", ")}], got "${t.__kind}".`);const i=n.encode(o),s=e[o][1].encode(t);return r.mergeBytes([i,s])}}}function x(e,t={}){const n=t.size??o.getU8Decoder();return{...S(e,n,t.description),decode:(t,o=0)=>{r.assertByteArrayIsNotEmptyForCodec("dataEnum",t,o);const[i,s]=n.decode(t,o);o=s;const a=e[Number(i)]??null;if(!a)throw new Error(`Enum discriminator out of range. Expected a number between 0 and ${e.length-1}, got ${i}.`);const[c,d]=a[1].decode(t,o);return o=d,[{__kind:a[0],...c??{}},o]}}}function v(e,t,n,r){if("remainder"===n&&(null===e.fixedSize||null===t.fixedSize))throw new Error('Codecs of "remainder" size must have fixed-size items.');return{description:r??`map(${e.description}, ${t.description}; ${a(n)})`,fixedSize:c(n,[e.fixedSize,t.fixedSize]),maxSize:c(n,[e.maxSize,t.maxSize])}}function A(e,t,n={}){const i=n.size??o.getU32Encoder();return{...v(e,t,i,n.description),encode:n=>{"number"==typeof i&&u("map",i,n.size);const o=Array.from(n,(([n,o])=>r.mergeBytes([e.encode(n),t.encode(o)])));return r.mergeBytes([d(i,n.size),...o])}}}function z(e,t,n={}){const r=n.size??o.getU32Decoder();return{...v(e,t,r,n.description),decode:(n,o=0)=>{const i=new Map;if("object"==typeof r&&0===n.slice(o).length)return[i,o];const[a,c]=s(r,[e.fixedSize,t.fixedSize],n,o);o=c;for(let r=0;r<a;r+=1){const[r,s]=e.decode(n,o);o=s;const[a,c]=t.decode(n,o);o=c,i.set(r,a)}return[i,o]}}}function I(e,t,n,o){let s=`; ${t.description}`,a=0===e.fixedSize?t.fixedSize:null;return n&&(r.assertFixedSizeCodec(e,"Fixed nullables can only be used with fixed-size codecs."),r.assertFixedSizeCodec(t,"Fixed nullables can only be used with fixed-size prefix."),s+="; fixed",a=t.fixedSize+e.fixedSize),{description:o??`nullable(${e.description+s})`,fixedSize:a,maxSize:i([t.maxSize,e.maxSize])}}function T(e,t={}){const n=t.prefix??o.getU8Encoder(),i=t.fixed??!1;return{...I(e,n,i,t.description),encode:t=>{const o=n.encode(Number(null!==t));let s=null!==t?e.encode(t):new Uint8Array;return s=i?r.fixBytes(s,e.fixedSize):s,r.mergeBytes([o,s])}}}function C(e,t={}){const n=t.prefix??o.getU8Decoder(),r=t.fixed??!1;return{...I(e,n,r,t.description),decode:(t,o=0)=>{if(t.length-o<=0)return[null,o];const i=o+(n.fixedSize??0)+(e.fixedSize??0),[s,a]=n.decode(t,o);if(o=a,0===s)return[null,r?i:o];const[c,d]=e.decode(t,o);return o=d,[c,r?i:o]}}}function k(e,t,n){const r=Object.keys(e),o=Object.values(e),i=o.some((e=>"number"==typeof e)),s=o.filter((e=>"string"==typeof e)).join(", "),a=i?o.length/2-1:o.length-1,c=i?[...r]:[...new Set([...r,...o])];return{description:n??`enum(${s}; ${t.description})`,enumKeys:r,enumValues:o,fixedSize:t.fixedSize,isNumericEnum:i,maxRange:a,maxSize:t.maxSize,minRange:0,stringValues:c}}function B(e,t={}){const n=t.size??o.getU8Encoder(),{description:r,fixedSize:i,maxSize:s,minRange:a,maxRange:c,stringValues:d,enumKeys:u,enumValues:l}=k(e,n,t.description);return{description:r,encode:e=>{const t="number"==typeof e&&(e<a||e>c),r="string"==typeof e&&!d.includes(e);if(t||r)throw new Error(`Invalid scalar enum variant. Expected one of [${d.join(", ")}] or a number between ${a} and ${c}, got "${e}".`);if("number"==typeof e)return n.encode(e);const o=l.indexOf(e);return o>=0?n.encode(o):n.encode(u.indexOf(e))},fixedSize:i,maxSize:s}}function D(e,t={}){const n=t.size??o.getU8Decoder(),{description:i,fixedSize:s,maxSize:a,minRange:c,maxRange:d,isNumericEnum:u,enumValues:l}=k(e,n,t.description);return{decode:(e,t=0)=>{r.assertByteArrayIsNotEmptyForCodec("enum",e,t);const[o,i]=n.decode(e,t),s=Number(o);if(t=i,s<c||s>d)throw new Error(`Enum discriminator out of range. Expected a number between ${c} and ${d}, got ${s}.`);return[u?s:l[s],t]},description:i,fixedSize:s,maxSize:a}}function N(e,t,n){if("remainder"===t&&null===e.fixedSize)throw new Error('Codecs of "remainder" size must have fixed-size items.');return{description:n??`set(${e.description}; ${a(t)})`,fixedSize:c(t,[e.fixedSize]),maxSize:c(t,[e.maxSize])}}function U(e,t={}){const n=t.size??o.getU32Encoder();return{...N(e,n,t.description),encode:t=>{"number"==typeof n&&t.size!==n&&u("set",n,t.size);const o=Array.from(t,(t=>e.encode(t)));return r.mergeBytes([d(n,t.size),...o])}}}function R(e,t={}){const n=t.size??o.getU32Decoder();return{...N(e,n,t.description),decode:(t,r=0)=>{const o=new Set;if("object"==typeof n&&0===t.slice(r).length)return[o,r];const[i,a]=s(n,[e.fixedSize],t,r);r=a;for(let n=0;n<i;n+=1){const[n,i]=e.decode(t,r);r=i,o.add(n)}return[o,r]}}}function O(e,t){const n=e.map((([e,t])=>`${String(e)}: ${t.description}`)).join(", ");return{description:t??`struct(${n})`,fixedSize:i(e.map((([,e])=>e.fixedSize))),maxSize:i(e.map((([,e])=>e.maxSize)))}}function $(e,t={}){return{...O(e,t.description),encode:t=>{const n=e.map((([e,n])=>n.encode(t[e])));return r.mergeBytes(n)}}}function L(e,t={}){return{...O(e,t.description),decode:(t,n=0)=>{const r={};return e.forEach((([e,o])=>{const[i,s]=o.decode(t,n);n=s,r[e]=i})),[r,n]}}}function P(e,t){const n=e.map((e=>e.description)).join(", ");return{description:t??`tuple(${n})`,fixedSize:i(e.map((e=>e.fixedSize))),maxSize:i(e.map((e=>e.maxSize)))}}function _(e,t={}){return{...P(e,t.description),encode:t=>(u("tuple",e.length,t.length),r.mergeBytes(e.map(((e,n)=>e.encode(t[n])))))}}function j(e,t={}){return{...P(e,t.description),decode:(t,n=0)=>{const r=[];return e.forEach((e=>{const[o,i]=e.decode(t,n);r.push(o),n=i})),[r,n]}}}function F(e={}){return{description:e.description??"unit",encode:()=>new Uint8Array,fixedSize:0,maxSize:0}}function M(e={}){return{decode:(e,t=0)=>[void 0,t],description:e.description??"unit",fixedSize:0,maxSize:0}}t.assertValidNumberOfItemsForCodec=u,t.decodeArrayLikeCodecSize=s,t.getArrayCodec=function(e,t={}){return r.combineCodec(f(e,t),g(e,t))},t.getArrayDecoder=g,t.getArrayEncoder=f,t.getArrayLikeCodecSizeDescription=a,t.getArrayLikeCodecSizeFromChildren=c,t.getArrayLikeCodecSizePrefix=d,t.getBitArrayCodec=(e,t={})=>r.combineCodec(p(e,t),m(e,t)),t.getBitArrayDecoder=m,t.getBitArrayEncoder=p,t.getBooleanCodec=function(e={}){return r.combineCodec(h(e),y(e))},t.getBooleanDecoder=y,t.getBooleanEncoder=h,t.getBytesCodec=function(e={}){return r.combineCodec(b(e),w(e))},t.getBytesDecoder=w,t.getBytesEncoder=b,t.getDataEnumCodec=function(e,t={}){return r.combineCodec(E(e,t),x(e,t))},t.getDataEnumDecoder=x,t.getDataEnumEncoder=E,t.getMapCodec=function(e,t,n={}){return r.combineCodec(A(e,t,n),z(e,t,n))},t.getMapDecoder=z,t.getMapEncoder=A,t.getNullableCodec=function(e,t={}){return r.combineCodec(T(e,t),C(e,t))},t.getNullableDecoder=C,t.getNullableEncoder=T,t.getScalarEnumCodec=function(e,t={}){return r.combineCodec(B(e,t),D(e,t))},t.getScalarEnumDecoder=D,t.getScalarEnumEncoder=B,t.getSetCodec=function(e,t={}){return r.combineCodec(U(e,t),R(e,t))},t.getSetDecoder=R,t.getSetEncoder=U,t.getStructCodec=function(e,t={}){return r.combineCodec($(e,t),L(e,t))},t.getStructDecoder=L,t.getStructEncoder=$,t.getTupleCodec=function(e,t={}){return r.combineCodec(_(e,t),j(e,t))},t.getTupleDecoder=j,t.getTupleEncoder=_,t.getUnitCodec=function(e={}){return r.combineCodec(F(e),M(e))},t.getUnitDecoder=M,t.getUnitEncoder=F},638:(e,t,n)=>{"use strict";var r=n(433);function o(e,t,n,r){if(r<t||r>n)throw new Error(`Codec [${e}] expected number to be in the range [${t}, ${n}], got ${r}.`)}var i=(e=>(e[e.LITTLE=0]="LITTLE",e[e.BIG=1]="BIG",e))(i||{});function s(e){let t,n=e.name;return e.size>1&&(t=!("endian"in e.options)||0===e.options.endian,n+=t?"(le)":"(be)"),{description:e.options.description??n,fixedSize:e.size,littleEndian:t,maxSize:e.size}}function a(e){const t=s(e);return{description:t.description,encode(n){e.range&&o(e.name,e.range[0],e.range[1],n);const r=new ArrayBuffer(e.size);return e.set(new DataView(r),n,t.littleEndian),new Uint8Array(r)},fixedSize:t.fixedSize,maxSize:t.maxSize}}function c(e){const t=s(e);return{decode(n,o=0){r.assertByteArrayIsNotEmptyForCodec(t.description,n,o),r.assertByteArrayHasEnoughBytesForCodec(t.description,e.size,n,o);const i=new DataView(function(e,t,n){const r=e.byteOffset+(t??0),o=n??e.byteLength;return e.buffer.slice(r,r+o)}(n,o,e.size));return[e.get(i,t.littleEndian),o+e.size]},description:t.description,fixedSize:t.fixedSize,maxSize:t.maxSize}}var d=(e={})=>a({name:"f32",options:e,set:(e,t,n)=>e.setFloat32(0,t,n),size:4}),u=(e={})=>c({get:(e,t)=>e.getFloat32(0,t),name:"f32",options:e,size:4}),l=(e={})=>a({name:"f64",options:e,set:(e,t,n)=>e.setFloat64(0,t,n),size:8}),f=(e={})=>c({get:(e,t)=>e.getFloat64(0,t),name:"f64",options:e,size:8}),g=(e={})=>a({name:"i128",options:e,range:[-BigInt("0x7fffffffffffffffffffffffffffffff")-1n,BigInt("0x7fffffffffffffffffffffffffffffff")],set:(e,t,n)=>{const r=n?8:0,o=n?0:8;e.setBigInt64(r,BigInt(t)>>64n,n),e.setBigUint64(o,0xffffffffffffffffn&BigInt(t),n)},size:16}),p=(e={})=>c({get:(e,t)=>{const n=t?8:0,r=t?0:8;return(e.getBigInt64(n,t)<<64n)+e.getBigUint64(r,t)},name:"i128",options:e,size:16}),m=(e={})=>a({name:"i16",options:e,range:[-Number("0x7fff")-1,Number("0x7fff")],set:(e,t,n)=>e.setInt16(0,t,n),size:2}),h=(e={})=>c({get:(e,t)=>e.getInt16(0,t),name:"i16",options:e,size:2}),y=(e={})=>a({name:"i32",options:e,range:[-Number("0x7fffffff")-1,Number("0x7fffffff")],set:(e,t,n)=>e.setInt32(0,t,n),size:4}),b=(e={})=>c({get:(e,t)=>e.getInt32(0,t),name:"i32",options:e,size:4}),w=(e={})=>a({name:"i64",options:e,range:[-BigInt("0x7fffffffffffffff")-1n,BigInt("0x7fffffffffffffff")],set:(e,t,n)=>e.setBigInt64(0,BigInt(t),n),size:8}),S=(e={})=>c({get:(e,t)=>e.getBigInt64(0,t),name:"i64",options:e,size:8}),E=(e={})=>a({name:"i8",options:e,range:[-Number("0x7f")-1,Number("0x7f")],set:(e,t)=>e.setInt8(0,t),size:1}),x=(e={})=>c({get:e=>e.getInt8(0),name:"i8",options:e,size:1}),v=(e={})=>({description:e.description??"shortU16",encode:e=>{o("shortU16",0,65535,e);const t=[0];for(let n=0;;n+=1){const r=e>>7*n;if(0===r)break;const o=127&r;t[n]=o,n>0&&(t[n-1]|=128)}return new Uint8Array(t)},fixedSize:null,maxSize:3}),A=(e={})=>({decode:(e,t=0)=>{let n=0,r=0;for(;++r;){const o=r-1,i=e[t+o];if(n|=(127&i)<<7*o,0==(128&i))break}return[n,t+r]},description:e.description??"shortU16",fixedSize:null,maxSize:3}),z=(e={})=>a({name:"u128",options:e,range:[0,BigInt("0xffffffffffffffffffffffffffffffff")],set:(e,t,n)=>{const r=n?8:0,o=n?0:8;e.setBigUint64(r,BigInt(t)>>64n,n),e.setBigUint64(o,0xffffffffffffffffn&BigInt(t),n)},size:16}),I=(e={})=>c({get:(e,t)=>{const n=t?8:0,r=t?0:8;return(e.getBigUint64(n,t)<<64n)+e.getBigUint64(r,t)},name:"u128",options:e,size:16}),T=(e={})=>a({name:"u16",options:e,range:[0,Number("0xffff")],set:(e,t,n)=>e.setUint16(0,t,n),size:2}),C=(e={})=>c({get:(e,t)=>e.getUint16(0,t),name:"u16",options:e,size:2}),k=(e={})=>a({name:"u32",options:e,range:[0,Number("0xffffffff")],set:(e,t,n)=>e.setUint32(0,t,n),size:4}),B=(e={})=>c({get:(e,t)=>e.getUint32(0,t),name:"u32",options:e,size:4}),D=(e={})=>a({name:"u64",options:e,range:[0,BigInt("0xffffffffffffffff")],set:(e,t,n)=>e.setBigUint64(0,BigInt(t),n),size:8}),N=(e={})=>c({get:(e,t)=>e.getBigUint64(0,t),name:"u64",options:e,size:8}),U=(e={})=>a({name:"u8",options:e,range:[0,Number("0xff")],set:(e,t)=>e.setUint8(0,t),size:1}),R=(e={})=>c({get:e=>e.getUint8(0),name:"u8",options:e,size:1});t.Endian=i,t.assertNumberIsBetweenForCodec=o,t.getF32Codec=(e={})=>r.combineCodec(d(e),u(e)),t.getF32Decoder=u,t.getF32Encoder=d,t.getF64Codec=(e={})=>r.combineCodec(l(e),f(e)),t.getF64Decoder=f,t.getF64Encoder=l,t.getI128Codec=(e={})=>r.combineCodec(g(e),p(e)),t.getI128Decoder=p,t.getI128Encoder=g,t.getI16Codec=(e={})=>r.combineCodec(m(e),h(e)),t.getI16Decoder=h,t.getI16Encoder=m,t.getI32Codec=(e={})=>r.combineCodec(y(e),b(e)),t.getI32Decoder=b,t.getI32Encoder=y,t.getI64Codec=(e={})=>r.combineCodec(w(e),S(e)),t.getI64Decoder=S,t.getI64Encoder=w,t.getI8Codec=(e={})=>r.combineCodec(E(e),x(e)),t.getI8Decoder=x,t.getI8Encoder=E,t.getShortU16Codec=(e={})=>r.combineCodec(v(e),A(e)),t.getShortU16Decoder=A,t.getShortU16Encoder=v,t.getU128Codec=(e={})=>r.combineCodec(z(e),I(e)),t.getU128Decoder=I,t.getU128Encoder=z,t.getU16Codec=(e={})=>r.combineCodec(T(e),C(e)),t.getU16Decoder=C,t.getU16Encoder=T,t.getU32Codec=(e={})=>r.combineCodec(k(e),B(e)),t.getU32Decoder=B,t.getU32Encoder=k,t.getU64Codec=(e={})=>r.combineCodec(D(e),N(e)),t.getU64Decoder=N,t.getU64Encoder=D,t.getU8Codec=(e={})=>r.combineCodec(U(e),R(e)),t.getU8Decoder=R,t.getU8Encoder=U},738:(e,t,n)=>{"use strict";var r=n(433),o=n(638);function i(e,t,n=t){if(!t.match(new RegExp(`^[${e}]*$`)))throw new Error(`Expected a string of base ${e.length}, got [${n}].`)}var s=e=>{const t=e.length,n=BigInt(t);return{description:`base${t}`,encode(t){if(i(e,t),""===t)return new Uint8Array;const r=[...t];let o=r.findIndex((t=>t!==e[0]));o=-1===o?r.length:o;const s=Array(o).fill(0);if(o===r.length)return Uint8Array.from(s);const a=r.slice(o);let c=0n,d=1n;for(let t=a.length-1;t>=0;t-=1)c+=d*BigInt(e.indexOf(a[t])),d*=n;const u=[];for(;c>0n;)u.unshift(Number(c%256n)),c/=256n;return Uint8Array.from(s.concat(u))},fixedSize:null,maxSize:null}},a=e=>{const t=e.length,n=BigInt(t);return{decode(t,r=0){const o=0===r?t:t.slice(r);if(0===o.length)return["",0];let i=o.findIndex((e=>0!==e));i=-1===i?o.length:i;const s=e[0].repeat(i);if(i===o.length)return[s,t.length];let a=o.slice(i).reduce(((e,t)=>256n*e+BigInt(t)),0n);const c=[];for(;a>0n;)c.unshift(e[Number(a%n)]),a/=n;return[s+c.join(""),t.length]},description:`base${t}`,fixedSize:null,maxSize:null}},c=e=>r.combineCodec(s(e),a(e)),d="0123456789",u=()=>({description:"base16",encode(e){const t=e.toLowerCase();i("0123456789abcdef",t,e);const n=t.match(/.{1,2}/g);return Uint8Array.from(n?n.map((e=>parseInt(e,16))):[])},fixedSize:null,maxSize:null}),l="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",f=(e,t)=>({description:`base${e.length}`,encode(n){if(i(e,n),""===n)return new Uint8Array;const r=[...n].map((t=>e.indexOf(t)));return new Uint8Array(p(r,t,8,!1))},fixedSize:null,maxSize:null}),g=(e,t)=>({decode(n,r=0){const o=0===r?n:n.slice(r);return 0===o.length?["",n.length]:[p([...o],8,t,!0).map((t=>e[t])).join(""),n.length]},description:`base${e.length}`,fixedSize:null,maxSize:null});function p(e,t,n,r){const o=[];let i=0,s=0;const a=(1<<n)-1;for(const r of e)for(i=i<<t|r,s+=t;s>=n;)s-=n,o.push(i>>s&a);return r&&s>0&&o.push(i<<n-s&a),o}var m=()=>({description:"base64",encode(e){try{const t=atob(e).split("").map((e=>e.charCodeAt(0)));return new Uint8Array(t)}catch(t){throw new Error(`Expected a string of base 64, got [${e}].`)}},fixedSize:null,maxSize:null}),h=()=>({decode(e,t=0){const n=e.slice(t);return[btoa(String.fromCharCode(...n)),e.length]},description:"base64",fixedSize:null,maxSize:null}),y=e=>e.replace(/\u0000/g,""),b=globalThis.TextDecoder,w=globalThis.TextEncoder,S=()=>{let e;return{description:"utf8",encode:t=>new Uint8Array((e||(e=new w)).encode(t)),fixedSize:null,maxSize:null}},E=()=>{let e;return{decode(t,n=0){const r=(e||(e=new b)).decode(t.slice(n));return[y(r),t.length]},description:"utf8",fixedSize:null,maxSize:null}},x=(e={})=>{const t=e.size??o.getU32Encoder(),n=e.encoding??S(),i=e.description??`string(${n.description}; ${A(t)})`;return"variable"===t?{...n,description:i}:"number"==typeof t?r.fixEncoder(n,t,i):{description:i,encode:e=>{const o=n.encode(e),i=t.encode(o.length);return r.mergeBytes([i,o])},fixedSize:null,maxSize:null}},v=(e={})=>{const t=e.size??o.getU32Decoder(),n=e.encoding??E(),i=e.description??`string(${n.description}; ${A(t)})`;return"variable"===t?{...n,description:i}:"number"==typeof t?r.fixDecoder(n,t,i):{decode:(e,o=0)=>{r.assertByteArrayIsNotEmptyForCodec("string",e,o);const[i,s]=t.decode(e,o),a=Number(i);o=s;const c=e.slice(o,o+a);r.assertByteArrayHasEnoughBytesForCodec("string",a,c);const[d,u]=n.decode(c);return[d,o+=u]},description:i,fixedSize:null,maxSize:null}};function A(e){return"object"==typeof e?e.description:`${e}`}t.assertValidBaseString=i,t.getBase10Codec=()=>c(d),t.getBase10Decoder=()=>a(d),t.getBase10Encoder=()=>s(d),t.getBase16Codec=()=>r.combineCodec(u(),{decode:(e,t=0)=>[e.slice(t).reduce(((e,t)=>e+t.toString(16).padStart(2,"0")),""),e.length],description:"base16",fixedSize:null,maxSize:null}),t.getBase16Decoder=()=>({decode:(e,t=0)=>[e.slice(t).reduce(((e,t)=>e+t.toString(16).padStart(2,"0")),""),e.length],description:"base16",fixedSize:null,maxSize:null}),t.getBase16Encoder=u,t.getBase58Codec=()=>c(l),t.getBase58Decoder=()=>a(l),t.getBase58Encoder=()=>s(l),t.getBase64Codec=()=>r.combineCodec(m(),h()),t.getBase64Decoder=h,t.getBase64Encoder=m,t.getBaseXCodec=c,t.getBaseXDecoder=a,t.getBaseXEncoder=s,t.getBaseXResliceCodec=(e,t)=>r.combineCodec(f(e,t),g(e,t)),t.getBaseXResliceDecoder=g,t.getBaseXResliceEncoder=f,t.getStringCodec=(e={})=>r.combineCodec(x(e),v(e)),t.getStringDecoder=v,t.getStringEncoder=x,t.getUtf8Codec=()=>r.combineCodec(S(),E()),t.getUtf8Decoder=E,t.getUtf8Encoder=S,t.padNullCharacters=(e,t)=>e.padEnd(t,"\0"),t.removeNullCharacters=y},504:(e,t)=>{"use strict";t.pipe=function(e,...t){return t.reduce(((e,t)=>t(e)),e)}},824:(e,t)=>{"use strict";var n=(e=>(e[e.WRITABLE_SIGNER=3]="WRITABLE_SIGNER",e[e.READONLY_SIGNER=2]="READONLY_SIGNER",e[e.WRITABLE=1]="WRITABLE",e[e.READONLY=0]="READONLY",e))(n||{});t.AccountRole=n,t.downgradeRoleToNonSigner=function(e){return-3&e},t.downgradeRoleToReadonly=function(e){return-2&e},t.isSignerRole=function(e){return e>=2},t.isWritableRole=function(e){return 0!=(1&e)},t.mergeRoles=function(e,t){return e|t},t.upgradeRoleToSigner=function(e){return 2|e},t.upgradeRoleToWritable=function(e){return 1|e}},735:(e,t)=>{"use strict";function n(e,t,r){if(Array.isArray(e))return e.map(((e,o)=>n(e,[...t,o],r)));if("object"==typeof e&&null!==e){const o={};for(const i in e)Object.prototype.hasOwnProperty.call(e,i)&&(o[i]=n(e[i],[...t,i],r));return o}return"bigint"==typeof e?(r&&(e>Number.MAX_SAFE_INTEGER||e<-Number.MAX_SAFE_INTEGER)&&r(t,e),Number(e)):e}function r(e,t){return n(e,[],t)}var o,i,s={},a=[["data","parsed","info","tokenAmount","decimals"],["data","parsed","info","tokenAmount","uiAmount"],["data","parsed","info","rentExemptReserve","decimals"],["data","parsed","info","rentExemptReserve","uiAmount"],["data","parsed","info","delegatedAmount","decimals"],["data","parsed","info","delegatedAmount","uiAmount"],["data","parsed","info","extensions",s,"state","olderTransferFee","transferFeeBasisPoints"],["data","parsed","info","extensions",s,"state","newerTransferFee","transferFeeBasisPoints"],["data","parsed","info","extensions",s,"state","preUpdateAverageRate"],["data","parsed","info","extensions",s,"state","currentRate"]],c=[...a,["data","parsed","info","lastExtendedSlotStartIndex"],["data","parsed","info","slashPenalty"],["data","parsed","info","warmupCooldownRate"],["data","parsed","info","decimals"],["data","parsed","info","numRequiredSigners"],["data","parsed","info","numValidSigners"],["data","parsed","info","stake","delegation","warmupCooldownRate"],["data","parsed","info","exemptionThreshold"],["data","parsed","info","burnPercent"],["data","parsed","info","commission"],["data","parsed","info","votes",s,"confirmationCount"]];function d(e,t){return e.filter((e=>e[0]===s&&"number"==typeof t||e[0]===t)).map((e=>e.slice(1)))}function u(e,t){if(Array.isArray(e))return e.map(((e,n)=>u(e,d(t,n))));if("object"==typeof e&&null!==e){const n={};for(const[r,o]of Object.entries(e)){const e=d(t,r);n[r]=u(o,e)}return n}return"number"==typeof e&&0===t.length&&Number.isInteger(e)?BigInt(e):e}function l(e){return new Proxy({},{defineProperty:()=>!1,deleteProperty:()=>!1,get(...t){const[n,i]=t,a=i.toString();return function(...t){const n=e?.onIntegerOverflow;return{params:r(t,n?(e,t)=>n(a,e,t):void 0),responseProcessor:e=>function(e,t){return u(e,(t?(o||(o={accountNotifications:c.map((e=>["value",...e])),blockNotifications:[["value","block","blockTime"],["value","block","transactions",s,"meta","preTokenBalances",s,"accountIndex"],["value","block","transactions",s,"meta","preTokenBalances",s,"uiTokenAmount","decimals"],["value","block","transactions",s,"meta","postTokenBalances",s,"accountIndex"],["value","block","transactions",s,"meta","postTokenBalances",s,"uiTokenAmount","decimals"],["value","block","transactions",s,"meta","rewards",s,"commission"],["value","block","transactions",s,"meta","innerInstructions",s,"index"],["value","block","transactions",s,"meta","innerInstructions",s,"instructions",s,"programIdIndex"],["value","block","transactions",s,"meta","innerInstructions",s,"instructions",s,"accounts",s],["value","block","transactions",s,"transaction","message","addressTableLookups",s,"writableIndexes",s],["value","block","transactions",s,"transaction","message","addressTableLookups",s,"readonlyIndexes",s],["value","block","transactions",s,"transaction","message","instructions",s,"programIdIndex"],["value","block","transactions",s,"transaction","message","instructions",s,"accounts",s],["value","block","transactions",s,"transaction","message","header","numReadonlySignedAccounts"],["value","block","transactions",s,"transaction","message","header","numReadonlyUnsignedAccounts"],["value","block","transactions",s,"transaction","message","header","numRequiredSignatures"],["value","block","rewards",s,"commission"]],programNotifications:c.flatMap((e=>[["value",s,"account",...e],[s,"account",...e]]))}),o)[t]:void 0)??[])}(e,a),subscribeMethodName:a.replace(/Notifications$/,"Subscribe"),unsubscribeMethodName:a.replace(/Notifications$/,"Unsubscribe")}}}})}t.createSolanaRpcApi=function(e){return new Proxy({},{defineProperty:()=>!1,deleteProperty:()=>!1,get(...t){const[n,o]=t,d=o.toString();return function(...t){const n=e?.onIntegerOverflow,o=r(t,n?(e,t)=>n(d,e,t):void 0);return{methodName:d,params:o,responseProcessor:e=>function(e,t){return u(e,(t?(i||(i={getAccountInfo:c.map((e=>["value",...e])),getBlock:[["blockTime"],["transactions",s,"meta","preTokenBalances",s,"accountIndex"],["transactions",s,"meta","preTokenBalances",s,"uiTokenAmount","decimals"],["transactions",s,"meta","postTokenBalances",s,"accountIndex"],["transactions",s,"meta","postTokenBalances",s,"uiTokenAmount","decimals"],["transactions",s,"meta","rewards",s,"commission"],["transactions",s,"meta","innerInstructions",s,"index"],["transactions",s,"meta","innerInstructions",s,"instructions",s,"programIdIndex"],["transactions",s,"meta","innerInstructions",s,"instructions",s,"accounts",s],["transactions",s,"transaction","message","addressTableLookups",s,"writableIndexes",s],["transactions",s,"transaction","message","addressTableLookups",s,"readonlyIndexes",s],["transactions",s,"transaction","message","instructions",s,"programIdIndex"],["transactions",s,"transaction","message","instructions",s,"accounts",s],["transactions",s,"transaction","message","header","numReadonlySignedAccounts"],["transactions",s,"transaction","message","header","numReadonlyUnsignedAccounts"],["transactions",s,"transaction","message","header","numRequiredSignatures"],["rewards",s,"commission"]],getBlockTime:[[]],getClusterNodes:[[s,"featureSet"],[s,"shredVersion"]],getInflationGovernor:[["initial"],["foundation"],["foundationTerm"],["taper"],["terminal"]],getInflationRate:[["foundation"],["total"],["validator"]],getInflationReward:[[s,"commission"]],getMultipleAccounts:c.map((e=>["value",s,...e])),getProgramAccounts:c.flatMap((e=>[["value",s,"account",...e],[s,"account",...e]])),getRecentPerformanceSamples:[[s,"samplePeriodSecs"]],getTokenAccountBalance:[["value","decimals"],["value","uiAmount"]],getTokenAccountsByDelegate:a.map((e=>["value",s,"account",...e])),getTokenAccountsByOwner:a.map((e=>["value",s,"account",...e])),getTokenLargestAccounts:[["value",s,"decimals"],["value",s,"uiAmount"]],getTokenSupply:[["value","decimals"],["value","uiAmount"]],getTransaction:[["meta","preTokenBalances",s,"accountIndex"],["meta","preTokenBalances",s,"uiTokenAmount","decimals"],["meta","postTokenBalances",s,"accountIndex"],["meta","postTokenBalances",s,"uiTokenAmount","decimals"],["meta","rewards",s,"commission"],["meta","innerInstructions",s,"index"],["meta","innerInstructions",s,"instructions",s,"programIdIndex"],["meta","innerInstructions",s,"instructions",s,"accounts",s],["transaction","message","addressTableLookups",s,"writableIndexes",s],["transaction","message","addressTableLookups",s,"readonlyIndexes",s],["transaction","message","instructions",s,"programIdIndex"],["transaction","message","instructions",s,"accounts",s],["transaction","message","header","numReadonlySignedAccounts"],["transaction","message","header","numReadonlyUnsignedAccounts"],["transaction","message","header","numRequiredSignatures"]],getVersion:[["feature-set"]],getVoteAccounts:[["current",s,"commission"],["delinquent",s,"commission"]],simulateTransaction:c.map((e=>["value","accounts",s,...e]))}),i)[t]:void 0)??[])}(e,d)}}}})},t.createSolanaRpcSubscriptionsApi=l,t.createSolanaRpcSubscriptionsApi_UNSTABLE=function(e){return l(e)}},266:(e,t)=>{"use strict";var n=(()=>!1)(),r=class extends Error{constructor(e){super(`JSON-RPC 2.0 error (${e.code}): ${e.message}`),Error.captureStackTrace(this,this.constructor),this.code=e.code,this.data=e.data}get name(){return"SolanaJsonRpcError"}},o=0;function i(){const e=o;return o=(o+1)%Number.MAX_SAFE_INTEGER,e}function s(e,t){return{id:i(),jsonrpc:"2.0",method:e,params:t}}var a=globalThis.fetch,c=class extends Error{constructor(e){super(`HTTP error (${e.statusCode}): ${e.message}`),Error.captureStackTrace(this,this.constructor),this.statusCode=e.statusCode}get name(){return"SolanaHttpError"}},d={accept:!0,"content-length":!0,"content-type":!0},u={"accept-charset":!0,"accept-encoding":!0,"access-control-request-headers":!0,"access-control-request-method":!0,connection:!0,"content-length":!0,cookie:!0,date:!0,dnt:!0,expect:!0,host:!0,"keep-alive":!0,origin:!0,"permissions-policy":!0,referer:!0,te:!0,trailer:!0,"transfer-encoding":!0,upgrade:!0,via:!0},l=globalThis.WebSocket,f=Symbol(n?"This symbol is thrown from a socket's iterator when the connection is explicity aborted by the user":void 0);t.createHttpTransport=function({headers:e,url:t}){n&&e&&function(e){const t=Object.keys(e).filter((e=>{const t=e.toLowerCase();return!0===d[e.toLowerCase()]||!0===u[e.toLowerCase()]||t.startsWith("proxy-")||t.startsWith("sec-")}));if(t.length>0)throw new Error(`${t.length>1?"These headers are":"This header is"} forbidden: \`${t.join("`, `")}\`. Learn more at https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.`)}(e);const r=e&&function(e){const t={};for(const n in e)t[n.toLowerCase()]=e[n];return t}(e);return async function({payload:e,signal:n}){const o=JSON.stringify(e),i={body:o,headers:{...r,accept:"application/json","content-length":o.length.toString(),"content-type":"application/json; charset=utf-8"},method:"POST",signal:n},s=await a(t,i);if(!s.ok)throw new c({message:s.statusText,statusCode:s.status});return await s.json()}},t.createJsonRpc=function(e){return function(e){return new Proxy(e.api,{defineProperty:()=>!1,deleteProperty:()=>!1,get:(t,n,o)=>function(...i){const a=n.toString(),c=Reflect.get(t,a,o),d=c?c(...i):{methodName:a,params:i};return function(e,t){return{async send(n){const{methodName:o,params:i,responseProcessor:a}=t,c=s(o,i),d=await e.transport({payload:c,signal:n?.abortSignal});if("error"in d)throw new r(d.error);return a?a(d.result):d.result}}}(e,d)}})}(e)},t.createJsonSubscriptionRpc=function(e){return function(e){return new Proxy(e.api,{defineProperty:()=>!1,deleteProperty:()=>!1,get:(t,n,o)=>function(...i){const a=n.toString(),c=Reflect.get(t,a,o);if(!1===n.toString().endsWith("Notifications")&&!c)throw new Error("Either the notification name must end in 'Notifications' or the API must supply a subscription creator function to map between the notification name and the subscribe/unsubscribe method names.");const d=c?c(...i):{params:i,subscribeMethodName:a.replace(/Notifications$/,"Subscribe"),unsubscribeMethodName:a.replace(/Notifications$/,"Unsubscribe")};return function(e,{params:t,subscribeMethodName:n,unsubscribeMethodName:o,responseProcessor:i}){return{async subscribe({abortSignal:a}){let c;function d(){if(void 0!==c){const e=s(o,[c]);f.send_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(e).finally((()=>{u.abort()}))}else u.abort()}a.throwIfAborted(),a.addEventListener("abort",d);const u=new AbortController,l=s(n,t),f=await e.transport({payload:l,signal:u.signal});var g,p;g=f,p=function(){a.removeEventListener("abort",d)},(async()=>{try{for await(const e of g);}catch{}finally{p()}})();for await(const e of f)if("id"in e&&e.id===l.id){if("error"in e)throw new r(e.error);c=e.result;break}if(null==c)throw new Error("Failed to obtain a subscription id from the server");return{async*[Symbol.asyncIterator](){for await(const e of f){if(!("params"in e)||e.params.subscription!==c)continue;const t=e.params.result;yield i?i(t):t}}}}}}(e,d)}})}(e)},t.createWebSocketTransport=function({sendBufferHighWatermark:e,url:t}){if(!1===/^wss?:/i.test(t)){const e=t.match(/^([^:]+):/);throw new DOMException(e?`Failed to construct 'WebSocket': The URL's scheme must be either 'ws' or 'wss'. '${e[1]}:' is not allowed.`:`Failed to construct 'WebSocket': The URL '${t}' is invalid.`)}return async function({payload:n,signal:r}){r?.throwIfAborted();const o=await async function({sendBufferHighWatermark:e,signal:t,url:n}){return new Promise(((r,o)=>{t.addEventListener("abort",a,{once:!0});const i=new Map;function s(e){const t=[...i.values()].filter((e=>e.__hasPolled)).map((({onError:e})=>e));i.clear(),t.forEach((t=>{try{t(e)}catch{}}))}function a(){s(f),m.readyState!==l.CLOSED&&m.readyState!==l.CLOSING&&m.close(1e3)}function c(e){u||o(new Error("WebSocket failed to connect",{cause:e}))}let d,u=!1;function g(){u=!0,r({async send(t){const n=JSON.stringify(t);if(!d&&m.readyState===l.OPEN&&m.bufferedAmount>e){let t;const n=new Promise(((n,r)=>{const o=setInterval((()=>{m.readyState===l.OPEN&&m.bufferedAmount>e||(clearInterval(o),d=void 0,n())}),16);t=()=>{d=void 0,clearInterval(o),r(new Error("WebSocket was closed before payload could be sent"))}}));d={onCancel:t,promise:n}}d&&await d.promise,m.send(n)},async*[Symbol.asyncIterator](){const e=Symbol();i.set(e,{__hasPolled:!1,queuedMessages:[]});try{for(;;){const t=i.get(e);if(!t)throw new Error("Invariant: WebSocket message iterator is missing state storage");if(t.__hasPolled)throw new Error("Invariant: WebSocket message iterator state is corrupt; iterated without first resolving existing message promise");const n=t.queuedMessages;if(n.length)t.queuedMessages=[],yield*n;else try{yield await new Promise(((t,n)=>{i.set(e,{__hasPolled:!0,onError:n,onMessage:t})}))}catch(e){if(e===f)return;throw new Error("WebSocket connection closed",{cause:e})}}}finally{i.delete(e)}}})}function p({data:e}){const t=JSON.parse(e);i.forEach(((e,n)=>{if(e.__hasPolled){const{onMessage:r}=e;i.set(n,{__hasPolled:!1,queuedMessages:[]}),r(t)}else e.queuedMessages.push(t)}))}const m=new l(n);m.addEventListener("close",(function e(n){d?.onCancel(),t.removeEventListener("abort",a),m.removeEventListener("close",e),m.removeEventListener("error",c),m.removeEventListener("open",g),m.removeEventListener("message",p),s(n)})),m.addEventListener("error",c),m.addEventListener("open",g),m.addEventListener("message",p)}))}({sendBufferHighWatermark:e,signal:r,url:t});return r?.throwIfAborted(),await o.send(n),{[Symbol.asyncIterator]:o[Symbol.asyncIterator].bind(o),send_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:o.send.bind(o)}}}},676:(e,t)=>{"use strict";function n(e){switch(e){case"finalized":return 2;case"confirmed":return 1;case"processed":return 0;default:return(t=>{throw new Error(`Unrecognized commitment \`${e}\`.`)})()}}var r=18446744073709551615n;function o(e){if(e<0)throw new Error("Input for 64-bit unsigned integer cannot be negative");if(e>r)throw new Error("Input number is too large to be represented as a 64-bit unsigned integer")}function i(e){try{BigInt(e)}catch(t){throw new Error(`\`${e}\` cannot be parsed as a BigInt`,{cause:t})}}function s(e){if(Number.isNaN(Number(e)))throw new Error(`\`${e}\` cannot be parsed as a Number`)}function a(e){try{if(e>864e13||e<-864e13)throw new Error("Expected input number to be in the range [-8.64e15, 8.64e15]")}catch(t){throw new Error(`\`${e}\` is not a timestamp`,{cause:t})}}t.assertIsLamports=o,t.assertIsStringifiedBigInt=i,t.assertIsStringifiedNumber=s,t.assertIsUnixTimestamp=a,t.commitmentComparator=function(e,t){return e===t?0:n(e)<n(t)?-1:1},t.isLamports=function(e){return e>=0&&e<=r},t.isStringifiedBigInt=function(e){try{return BigInt(e),!0}catch(e){return!1}},t.isStringifiedNumber=function(e){return!Number.isNaN(Number(e))},t.isUnixTimestamp=function(e){return!(e>864e13||e<-864e13)},t.lamports=function(e){return o(e),e},t.stringifiedBigInt=function(e){return i(e),e},t.stringifiedNumber=function(e){return s(e),e},t.unixTimestamp=function(e){return a(e),e}},362:(e,t,n)=>{"use strict";var r,o=n(738),i=n(433),s=n(149),a=n(638),c=n(2),d=n(504),u=n(560),l=(()=>!1)();function f(e){if("signatures"in e){const{signatures:t,...n}=e;return n}return e}function g(e,t){if("lifetimeConstraint"in t&&t.lifetimeConstraint.blockhash===e.blockhash&&t.lifetimeConstraint.lastValidBlockHeight===e.lastValidBlockHeight)return t;const n={...f(t),lifetimeConstraint:e};return Object.freeze(n),n}function p({version:e}){const t={instructions:[],version:e};return Object.freeze(t),t}var m=(e=>(e[e.WRITABLE_SIGNER=3]="WRITABLE_SIGNER",e[e.READONLY_SIGNER=2]="READONLY_SIGNER",e[e.WRITABLE=1]="WRITABLE",e[e.READONLY=0]="READONLY",e))(m||{}),h=1;function y(e){return e>=2}function b(e){return 0!=(e&h)}function w(e,t){return e|t}var S="SysvarRecentB1ockHashes11111111111111111111",E="11111111111111111111111111111111";function x(e,t){return{accounts:[{address:e,role:m.WRITABLE},{address:S,role:m.READONLY},{address:t,role:m.READONLY_SIGNER}],data:new Uint8Array([4,0,0,0]),programAddress:E}}function v(e){return e.programAddress===E&&null!=e.data&&4===(t=e.data).byteLength&&4===t[0]&&0===t[1]&&0===t[2]&&0===t[3]&&3===e.accounts?.length&&null!=e.accounts[0].address&&e.accounts[0].role===m.WRITABLE&&e.accounts[1].address===S&&e.accounts[1].role===m.READONLY&&null!=e.accounts[2].address&&y(e.accounts[2].role);var t}function A(e){return"lifetimeConstraint"in e&&"string"==typeof e.lifetimeConstraint.nonce&&null!=e.instructions[0]&&v(e.instructions[0])}function z({nonce:e,nonceAccountAddress:t,nonceAuthorityAddress:n},r){let o;const i=r.instructions[0];if(i&&v(i))if(function(e,t,n){return e.accounts[0].address===t&&e.accounts[2].address===n}(i,t,n)){if(A(r)&&r.lifetimeConstraint.nonce===e)return r;o=[i,...r.instructions.slice(1)]}else o=[x(t,n),...r.instructions.slice(1)];else o=[x(t,n),...r.instructions];const s={...f(r),instructions:o,lifetimeConstraint:{nonce:e}};return Object.freeze(s),s}function I(e,t){if("feePayer"in t&&e===t.feePayer)return t;const n={...f(t),feePayer:e};return Object.freeze(n),n}function T(e,t){const n={...f(t),instructions:[...t.instructions,e]};return Object.freeze(n),n}function C(e,t,n){e[t]=n(e[t]??{role:m.READONLY})}var k=Symbol("AddressMapTypeProperty");function B(e){var t;const n={};for(const r of e){if(!("lookupTableAddress"in r))continue;const e=n[t=r.lookupTableAddress]||(n[t]={readableIndices:[],writableIndices:[]});r.role===m.WRITABLE?e.writableIndices.push(r.addressIndex):e.readableIndices.push(r.addressIndex)}return Object.keys(n).sort(c.getAddressComparator()).map((e=>({lookupTableAddress:e,...n[e]})))}function D(e){let t=0,n=0,r=0;for(const o of e){if("lookupTableAddress"in o)break;const e=b(o.role);y(o.role)?(r++,e||n++):e||t++}return{numReadonlyNonSignerAccounts:t,numReadonlySignerAccounts:n,numSignerAccounts:r}}function N(e,t){const n=function(e){const t={};for(const[n,r]of e.entries())t[r.address]=n;return t}(t);return e.map((({accounts:e,data:t,programAddress:r})=>({programAddressIndex:n[r],...e?{accountIndices:e.map((({address:e})=>n[e]))}:null,...t?{data:t}:null})))}function U(e){const t=e.findIndex((e=>"lookupTableAddress"in e));return(-1===t?e:e.slice(0,t)).map((({address:e})=>e))}function R(e){const t=function(e){let t;return Object.entries(e).sort((([e,n],[r,o])=>{if(n[k]!==o[k]){if(0===n[k])return-1;if(0===o[k])return 1;if(2===n[k])return-1;if(2===o[k])return 1}const i=y(n.role);if(i!==y(o.role))return i?-1:1;const s=b(n.role);return s!==b(o.role)?s?-1:1:(t||(t=c.getAddressComparator()),1===n[k]&&1===o[k]&&n.lookupTableAddress!==o.lookupTableAddress?t(n.lookupTableAddress,o.lookupTableAddress):t(e,r))})).map((([e,t])=>({address:e,...t})))}(function(e,t){const n={[e]:{[k]:0,role:m.WRITABLE_SIGNER}},r=new Set;for(const e of t){let t;if(C(n,e.programAddress,(t=>{if(r.add(e.programAddress),k in t){if(b(t.role)){if(0===t[k])throw new Error(`This transaction includes an address (\`${e.programAddress}\`) which is both invoked and set as the fee payer. Program addresses may not pay fees.`);throw new Error(`This transaction includes an address (\`${e.programAddress}\`) which is both invoked and marked writable. Program addresses may not be writable.`)}if(2===t[k])return t}return{[k]:2,role:m.READONLY}})),e.accounts)for(const o of e.accounts)C(n,o.address,(e=>{const{address:n,...i}=o;if(k in e)switch(e[k]){case 0:return e;case 1:{const n=w(e.role,i.role);if("lookupTableAddress"in i){if(e.lookupTableAddress!==i.lookupTableAddress&&(t||(t=c.getAddressComparator()))(i.lookupTableAddress,e.lookupTableAddress)<0)return{[k]:1,...i,role:n}}else if(y(i.role))return{[k]:2,role:n};return e.role!==n?{...e,role:n}:e}case 2:{const t=w(e.role,i.role);if(r.has(o.address)){if(b(i.role))throw new Error(`This transaction includes an address (\`${o.address}\`) which is both invoked and marked writable. Program addresses may not be writable.`);return e.role!==t?{...e,role:t}:e}return"lookupTableAddress"in i&&!y(e.role)?{...i,[k]:1,role:t}:e.role!==t?{...e,role:t}:e}}return"lookupTableAddress"in i?{...i,[k]:1}:{...i,[k]:2}}))}return n}(e.feePayer,e.instructions));return{..."legacy"!==e.version?{addressTableLookups:B(t)}:null,header:D(t),instructions:N(e.instructions,t),lifetimeToken:(n=e.lifetimeConstraint,"nonce"in n?n.nonce:n.blockhash),staticAccounts:U(t),version:e.version};var n}function O(e){const t=R(e);let n;if("signatures"in e){n=[];for(let r=0;r<t.header.numSignerAccounts;r++)n[r]=e.signatures[t.staticAccounts[r]]??new Uint8Array(Array(64).fill(0))}else n=Array(t.header.numSignerAccounts).fill(new Uint8Array(Array(64).fill(0)));return{compiledMessage:t,signatures:n}}var $,L,P,_,j=l?"The address of the address lookup table account from which instruction addresses should be looked up":"lookupTableAddress",F=l?"The indices of the accounts in the lookup table that should be loaded as writeable":"writableIndices",M=l?"The indices of the accounts in the lookup table that should be loaded as read-only":"readableIndices",K=l?"A pointer to the address of an address lookup table, along with the readonly/writeable indices of the addresses that should be loaded from it":"addressTableLookup";function W(e){const t=(P||(P=a.getU8Encoder()),P);return{...t,description:e??t.description}}function H(e){const t=(_||(_=a.getU8Decoder()),_);return{...t,description:e??t.description}}var V,G,q=l?"The expected number of addresses in the static address list belonging to accounts that are required to sign this transaction":void 0,Y=l?"The expected number of addresses in the static address list belonging to accounts that are required to sign this transaction, but may not be writable":void 0,J=l?"The expected number of addresses in the static address list belonging to accounts that are neither signers, nor writable":void 0,X=l?"The transaction message header containing counts of the signer, readonly-signer, and readonly-nonsigner account addresses":void 0,Z=l?"The index of the program being called, according to the well-ordered accounts list for this transaction":"programAddressIndex",Q=l?"The index of an account, according to the well-ordered accounts list for this transaction":void 0,ee=l?"An optional list of account indices, according to the well-ordered accounts list for this transaction, in the order in which the program being called expects them":"accountIndices",te=l?"An optional buffer of data passed to the instruction":"data",ne=128,re={description:l?"A single byte that encodes the version of the transaction":"",fixedSize:null,maxSize:1};function oe(e,t=0){const n=e[t];return 0==(n&ne)?["legacy",t]:[n^ne,t+1]}function ie(e){if("legacy"===e)return new Uint8Array;if(e<0||e>127)throw new Error(`Transaction version must be in the range [0, 127]. \`${e}\` given.`);return new Uint8Array([e|ne])}var se=l?"A compact-array of static account addresses belonging to this transaction":"staticAccounts",ae=l?"A 32-byte token that specifies the lifetime of this transaction (eg. a recent blockhash, or a durable nonce)":"lifetimeToken",ce=l?"A compact-array of instructions belonging to this transaction":"instructions",de=l?"A compact array of address table lookups belonging to this transaction":"addressTableLookups";function ue(){return[["version",{...re,encode:ie}],["header",s.getStructEncoder([["numSignerAccounts",W(q)],["numReadonlySignerAccounts",W(Y)],["numReadonlyNonSignerAccounts",W(J)]],{description:X})],["staticAccounts",s.getArrayEncoder(c.getAddressEncoder(),{description:se,size:a.getShortU16Encoder()})],["lifetimeToken",o.getStringEncoder({description:ae,encoding:o.getBase58Encoder(),size:32})],["instructions",s.getArrayEncoder((V||(V=i.mapEncoder(s.getStructEncoder([["programAddressIndex",a.getU8Encoder({description:Z})],["accountIndices",s.getArrayEncoder(a.getU8Encoder({description:Q}),{description:ee,size:a.getShortU16Encoder()})],["data",s.getBytesEncoder({description:te,size:a.getShortU16Encoder()})]]),(e=>void 0!==e.accountIndices&&void 0!==e.data?e:{...e,accountIndices:e.accountIndices??[],data:e.data??new Uint8Array(0)}))),V),{description:ce,size:a.getShortU16Encoder()})]]}var le=l?"The wire format of a Solana transaction message":"message";function fe(){return{description:le,encode:e=>"legacy"===e.version?s.getStructEncoder(ue()).encode(e):i.mapEncoder(s.getStructEncoder([...ue(),["addressTableLookups",s.getArrayEncoder(($||($=s.getStructEncoder([["lookupTableAddress",c.getAddressEncoder({description:j})],["writableIndices",s.getArrayEncoder(a.getU8Encoder(),{description:F,size:a.getShortU16Encoder()})],["readableIndices",s.getArrayEncoder(a.getU8Encoder(),{description:M,size:a.getShortU16Encoder()})]],{description:K})),$),{description:de,size:a.getShortU16Encoder()})]]),(e=>"legacy"===e.version?e:{...e,addressTableLookups:e.addressTableLookups??[]})).encode(e),fixedSize:null,maxSize:null}}var ge,pe,me=l?"A compact array of 64-byte, base-64 encoded Ed25519 signatures":"signatures",he=l?"The wire format of a Solana transaction":"transaction";function ye(){return i.mapEncoder(s.getStructEncoder([["signatures",s.getArrayEncoder(s.getBytesEncoder({size:64}),{description:me,size:a.getShortU16Encoder()})],["compiledMessage",fe()]],{description:he}),O)}function be(e){return i.mapDecoder(s.getStructDecoder([["signatures",s.getArrayDecoder(i.mapDecoder(s.getBytesDecoder({size:64}),(e=>e)),{description:me,size:a.getShortU16Decoder()})],["compiledMessage",i.mapDecoder(s.getStructDecoder([["version",{...re,decode:oe}],["header",s.getStructDecoder([["numSignerAccounts",H(q)],["numReadonlySignerAccounts",H(Y)],["numReadonlyNonSignerAccounts",H(J)]],{description:X})],["staticAccounts",s.getArrayDecoder(c.getAddressDecoder(),{description:se,size:a.getShortU16Decoder()})],["lifetimeToken",o.getStringDecoder({description:ae,encoding:o.getBase58Decoder(),size:32})],["instructions",s.getArrayDecoder((G||(G=i.mapDecoder(s.getStructDecoder([["programAddressIndex",a.getU8Decoder({description:Z})],["accountIndices",s.getArrayDecoder(a.getU8Decoder({description:Q}),{description:ee,size:a.getShortU16Decoder()})],["data",s.getBytesDecoder({description:te,size:a.getShortU16Decoder()})]]),(e=>{if(e.accountIndices.length&&e.data.byteLength)return e;const{accountIndices:t,data:n,...r}=e;return{...r,...t.length?{accountIndices:t}:null,...n.byteLength?{data:n}:null}}))),G),{description:ce,size:a.getShortU16Decoder()})],["addressTableLookups",s.getArrayDecoder((L||(L=s.getStructDecoder([["lookupTableAddress",c.getAddressDecoder({description:j})],["writableIndices",s.getArrayDecoder(a.getU8Decoder(),{description:F,size:a.getShortU16Decoder()})],["readableIndices",s.getArrayDecoder(a.getU8Decoder(),{description:M,size:a.getShortU16Decoder()})]],{description:K})),L),{description:de,size:a.getShortU16Decoder()})]],{description:le}),(({addressTableLookups:e,...t})=>"legacy"!==t.version&&e?.length?{...t,addressTableLookups:e}:t))]],{description:he}),(t=>function(e,t){const{compiledMessage:n}=e;if("addressTableLookups"in n&&n.addressTableLookups.length>0)throw new Error("Cannot convert transaction with addressTableLookups");const r=n.staticAccounts[0];if(!r)throw new Error("No fee payer set in CompiledTransaction");const o=function(e){const{header:t}=e,n=t.numSignerAccounts-t.numReadonlySignerAccounts,r=e.staticAccounts.length-t.numSignerAccounts-t.numReadonlyNonSignerAccounts,o=[];let i=0;for(let t=0;t<n;t++)o.push({address:e.staticAccounts[i],role:m.WRITABLE_SIGNER}),i++;for(let n=0;n<t.numReadonlySignerAccounts;n++)o.push({address:e.staticAccounts[i],role:m.READONLY_SIGNER}),i++;for(let t=0;t<r;t++)o.push({address:e.staticAccounts[i],role:m.WRITABLE}),i++;for(let n=0;n<t.numReadonlyNonSignerAccounts;n++)o.push({address:e.staticAccounts[i],role:m.READONLY}),i++;return o}(n),i=n.instructions.map((e=>function(e,t){const n=t[e.programAddressIndex]?.address;if(!n)throw new Error(`Could not find program address at index ${e.programAddressIndex}`);const r=e.accountIndices?.map((e=>t[e])),{data:o}=e;return{programAddress:n,...r&&r.length?{accounts:r}:{},...o&&o.length?{data:o}:{}}}(e,o))),s=i[0],a=function(e,t,n){if(t&&v(t)){const n=t.accounts[0].address;c.assertIsAddress(n);const r=t.accounts[2].address;return c.assertIsAddress(r),{nonce:e,nonceAccountAddress:n,nonceAuthorityAddress:r}}return{blockhash:e,lastValidBlockHeight:n??2n**64n-1n}}(n.lifetimeToken,s,t),u=function(e){const{compiledMessage:{staticAccounts:t},signatures:n}=e;return n.reduce(((e,n,r)=>{if(n.every((e=>0===e)))return e;const o=t[r];return{...e,[o]:n}}),{})}(e);return d.pipe(p({version:n.version}),(e=>I(r,e)),(e=>i.reduce(((e,t)=>T(t,e)),e)),(e=>"blockhash"in a?g(a,e):z(a,e)),(t=>e.signatures.length?{...t,signatures:u}:t))}(t,e)))}function we(e){ge||(ge=o.getBase58Encoder());try{if(e.length<64||e.length>88)throw new Error("Expected input string to decode to a byte array of length 64.");const t=ge.encode(e).byteLength;if(64!==t)throw new Error(`Expected input string to decode to a byte array of length 64. Actual length: ${t}`)}catch(t){throw new Error(`\`${e}\` is not a transaction signature`,{cause:t})}}t.appendTransactionInstruction=T,t.assertIsBlockhash=function(e){r||(r=o.getBase58Encoder());try{if(e.length<32||e.length>44)throw new Error("Expected input string to decode to a byte array of length 32.");const t=r.encode(e).byteLength;if(32!==t)throw new Error(`Expected input string to decode to a byte array of length 32. Actual length: ${t}`)}catch(t){throw new Error(`\`${e}\` is not a blockhash`,{cause:t})}},t.assertIsDurableNonceTransaction=function(e){if(!A(e))throw new Error("Transaction is not a durable nonce transaction")},t.assertIsTransactionSignature=we,t.assertTransactionIsFullySigned=function(e){const t=e.instructions.flatMap((e=>e.accounts?.filter((e=>y(e.role)))??[])).map((e=>e.address));new Set([e.feePayer,...t]).forEach((t=>{if(!e.signatures[t])throw new Error(`Transaction is missing signature for address \`${t}\``)}))},t.createTransaction=p,t.getBase64EncodedWireTransaction=function(e){const t=ye().encode(e);return btoa(String.fromCharCode(...t))},t.getSignatureFromTransaction=function(e){pe||(pe=o.getBase58Decoder());const t=e.signatures[e.feePayer];if(!t)throw new Error("Could not determine this transaction's signature. Make sure that the transaction has been signed by its fee payer.");return pe.decode(t)[0]},t.getTransactionCodec=function(e){return i.combineCodec(ye(),be(e))},t.getTransactionDecoder=be,t.getTransactionEncoder=ye,t.isAdvanceNonceAccountInstruction=v,t.isTransactionSignature=function(e){return ge||(ge=o.getBase58Encoder()),!(e.length<64||e.length>88)&&64===ge.encode(e).byteLength},t.prependTransactionInstruction=function(e,t){const n={...f(t),instructions:[e,...t.instructions]};return Object.freeze(n),n},t.setTransactionFeePayer=I,t.setTransactionLifetimeUsingBlockhash=g,t.setTransactionLifetimeUsingDurableNonce=z,t.signTransaction=async function(e,t){const n=R(t),r="signatures"in t?{...t.signatures}:{},o=fe().encode(n),i=await Promise.all(e.map((e=>Promise.all([c.getAddressFromPublicKey(e.publicKey),u.signBytes(e.privateKey,o)]))));for(const[e,t]of i)r[e]=t;const s={...t,signatures:r};return Object.freeze(s),s},t.transactionSignature=function(e){return we(e),e}},560:(e,t,n)=>{"use strict";var r=n(929);t.generateKeyPair=async function(){return await r.assertKeyGenerationIsAvailable(),await crypto.subtle.generateKey("Ed25519",!1,["sign","verify"])},t.signBytes=async function(e,t){await r.assertSigningCapabilityIsAvailable();const n=await crypto.subtle.sign("Ed25519",e,t);return new Uint8Array(n)},t.verifySignature=async function(e,t,n){return await r.assertVerificationCapabilityIsAvailable(),await crypto.subtle.verify("Ed25519",e,t,n)}},780:(e,t,n)=>{"use strict";var r=n(2),o=n(824),i=n(920),s=n(676),a=n(362),c=n(504),d=n(735),u=n(266),l=n(393),f=n(738);function g(e){return e&&e.__esModule?e:{default:e}}var p=g(l),m=(()=>!1)();async function h(e,t,n){const{abortSignal:r,commitment:o,getRecentSignatureConfirmationPromise:i}=t;r?.throwIfAborted();const s=new AbortController;if(r){const e=()=>{s.abort()};r.addEventListener("abort",e,{signal:s.signal})}try{const r=n({...t,abortSignal:s.signal});return await Promise.race([i({abortSignal:s.signal,commitment:o,signature:e}),...r])}finally{s.abort()}}function y(e,t){return async function({abortSignal:n,commitment:r,signature:o}){const i=new AbortController;n.addEventListener("abort",(function(){i.abort()}),{signal:i.signal});const a=await t.signatureNotifications(o,{commitment:r}).subscribe({abortSignal:i.signal}),c=(async()=>{for await(const e of a){if(e.value.err)throw new Error(`The transaction with signature \`${o}\` failed.`,{cause:e.value.err});return}})(),d=(async()=>{const{value:t}=await e.getSignatureStatuses([o]).send({abortSignal:i.signal}),n=t[0];n&&n.confirmationStatus&&s.commitmentComparator(n.confirmationStatus,r)>=0||await new Promise((()=>{}))})();try{return await Promise.race([c,d])}finally{i.abort()}}}async function b({abortSignal:e,commitment:t}){return await new Promise(((n,r)=>{e.addEventListener("abort",(e=>{clearTimeout(s);const t=new DOMException(e.target.reason,"AbortError");r(t)}));const o="processed"===t?3e4:6e4,i=performance.now(),s=setTimeout((()=>{const e=performance.now()-i;r(new DOMException(`Timeout elapsed after ${e} ms`,"TimeoutError"))}),o)}))}async function w({abortSignal:e,commitment:t,confirmSignatureOnlyTransaction:n,lamports:r,recipientAddress:o,rpc:i}){const s=await i.requestAirdrop(o,r,{commitment:t}).send({abortSignal:e});return await n({abortSignal:e,commitment:t,signature:s}),s}var S=class extends Error{constructor(e,t,n){const r=("number"==typeof t[0]?t[0]:parseInt(t[0],10))+1;let o="";const i=r%10,s=r%100;o=1==i&&11!=s?r+"st":2==i&&12!=s?r+"nd":3==i&&13!=s?r+"rd":r+"th";const a=t.length>1?t.slice(1).map((e=>"number"==typeof e?`[${e}]`:e)).join("."):null;super(`The ${o} argument to the \`${e}\` RPC method${a?` at path \`${a}\``:""} was \`${n}\`. This number is unsafe for use with the Solana JSON-RPC because it exceeds \`Number.MAX_SAFE_INTEGER\`.`),this.keyPath=t,this.methodName=e,this.value=n}get name(){return"SolanaJsonRpcIntegerOverflowError"}},E={onIntegerOverflow(e,t,n){throw new S(e,t,n)}};function x({getAbortSignalFromInputArgs:e,getCacheEntryMissingError:t,getCacheKeyFromInputArgs:n,onCacheHit:r,onCreateIterable:o}){const i=new Map;return async(...s)=>{const a=n(...s),c=e(...s);if(void 0===a)return await o(c,...s);const d=()=>{i.delete(a),c.removeEventListener("abort",u)},u=()=>{const e=function(e){const n=i.get(e);if(!n)throw t(e);return n}(a);!0!==e.purgeScheduled&&(e.purgeScheduled=!0,globalThis.queueMicrotask((()=>{e.purgeScheduled=!1,0===e.referenceCount&&(e.abortController.abort(),d())}))),e.referenceCount--};c.addEventListener("abort",u);try{const e=i.get(a);if(e){e.referenceCount++;const t=e.iterable,n="then"in t?await t:t;return await r(n,...s),n}{const e=new AbortController,t=o(e.signal,...s),n={abortController:e,iterable:t,purgeScheduled:!1,referenceCount:1};i.set(a,n);const r=await t;return l=r,f=d,(async()=>{try{for await(const e of l);}catch{}finally{f()}})(),n.iterable=r,r}}catch(e){throw d(),e}var l,f}}var v=Symbol(m?"This symbol is thrown from a subscription's iterator when the subscription is explicitly aborted by the user":void 0);function A(e){return function(e){return null!=e&&"object"==typeof e&&!Array.isArray(e)&&"jsonrpc"in e&&"2.0"===e.jsonrpc&&"method"in e&&"string"==typeof e.method&&"params"in e}(e)?p.default([e.method,e.params]):void 0}function z(e){const t={};for(const n in e)t[n.toLowerCase()]=e[n];return t}var I={jsonrpc:"2.0",method:"ping"},T=Symbol(m?"Cache key to use when there is no connection sharding strategy":void 0);function C(e){return async function({abortSignal:t,lastValidBlockHeight:n}){const r=new AbortController;t.addEventListener("abort",(function(){r.abort()}),{signal:r.signal});const o=await e.slotNotifications().subscribe({abortSignal:r.signal});try{for await(const e of o)if(e.slot>n)throw new Error("The network has progressed past the last block for which this transaction could have committed.")}finally{r.abort()}}}var k=40;function B(e,t){return async function({abortSignal:n,commitment:r,currentNonceValue:o,nonceAccountAddress:i}){const s=new AbortController;n.addEventListener("abort",(function(){s.abort()}),{signal:s.signal});const a=await t.accountNotifications(i,{commitment:r,encoding:"base64"}).subscribe({abortSignal:s.signal}),c=f.getBase58Decoder(),d=f.getBase64Encoder();function u([e]){const t=d.encode(e).slice(k,k+32);return c.decode(t)[0]}const l=(async()=>{for await(const e of a){const t=u(e.value.data);if(t!==o)throw new Error(`The nonce \`${o}\` is no longer valid. It has advanced to \`${t}\`.`)}})(),g=(async()=>{const{value:t}=await e.getAccountInfo(i,{commitment:r,dataSlice:{length:32,offset:k},encoding:"base58"}).send({abortSignal:s.signal});if(!t)throw new Error(`No nonce account could be found at address \`${i}\`.`);const n=t.data[0];if(n!==o)throw new Error(`The nonce \`${o}\` is no longer valid. It has advanced to \`${n}\`.`);await new Promise((()=>{}))})();try{return await Promise.race([l,g])}finally{s.abort()}}}function D({rpc:e,rpcSubscriptions:t}){const n=B(e,t),r=y(e,t);return async function(e){await U({...e,getNonceInvalidationPromise:n,getRecentSignatureConfirmationPromise:r})}}function N({rpc:e,rpcSubscriptions:t}){const n=C(t),r=y(e,t);return async function(e){await R({...e,getBlockHeightExceedencePromise:n,getRecentSignatureConfirmationPromise:r})}}async function U(e){await h(a.getSignatureFromTransaction(e.transaction),e,(function({abortSignal:e,commitment:t,getNonceInvalidationPromise:n,transaction:r}){return[n({abortSignal:e,commitment:t,currentNonceValue:r.lifetimeConstraint.nonce,nonceAccountAddress:r.instructions[0].accounts[0].address})]}))}async function R(e){await h(a.getSignatureFromTransaction(e.transaction),e,(function({abortSignal:e,getBlockHeightExceedencePromise:t,transaction:n}){return[t({abortSignal:e,lastValidBlockHeight:n.lifetimeConstraint.lastValidBlockHeight})]}))}function O(e,t){return!t?.preflightCommitment&&s.commitmentComparator(e,"finalized")<0?{...t,preflightCommitment:e}:t}async function $({abortSignal:e,commitment:t,rpc:n,transaction:r,...o}){const i=a.getBase64EncodedWireTransaction(r);return await n.sendTransaction(i,{...O(t,o),encoding:"base64"}).send({abortSignal:e})}async function L({abortSignal:e,commitment:t,confirmDurableNonceTransaction:n,rpc:r,transaction:o,...i}){const s=await $({...i,abortSignal:e,commitment:t,rpc:r,transaction:o});return await n({abortSignal:e,commitment:t,transaction:o}),s}async function P({abortSignal:e,commitment:t,confirmRecentTransaction:n,rpc:r,transaction:o,...i}){const s=await $({...i,abortSignal:e,commitment:t,rpc:r,transaction:o});return await n({abortSignal:e,commitment:t,transaction:o}),s}t.createBlockHeightExceedencePromiseFactory=C,t.createDefaultAirdropRequester=function({rpc:e,rpcSubscriptions:t}){const n=function({rpc:e,rpcSubscriptions:t}){const n=y(e,t);return async function(e){await async function(e){await h(e.signature,e,(function({abortSignal:e,commitment:t,getTimeoutPromise:n}){return[n({abortSignal:e,commitment:t})]}))}({...e,getRecentSignatureConfirmationPromise:n,getTimeoutPromise:b})}}({rpc:e,rpcSubscriptions:t});return async function(t){return await w({...t,confirmSignatureOnlyTransaction:n,rpc:e})}},t.createDefaultDurableNonceTransactionConfirmer=D,t.createDefaultDurableNonceTransactionSender=function({rpc:e,rpcSubscriptions:t}){const n=D({rpc:e,rpcSubscriptions:t});return async function(t,r){await L({...r,confirmDurableNonceTransaction:n,rpc:e,transaction:t})}},t.createDefaultRecentTransactionConfirmer=N,t.createDefaultRpcSubscriptionsTransport=function(e){const{getShard:t,intervalMs:n,...r}=e;return c.pipe(u.createWebSocketTransport({...r,sendBufferHighWatermark:e.sendBufferHighWatermark??131072}),(e=>function({intervalMs:e,transport:t}){const n=new Map;return async(...r)=>{const o=await t(...r);let i;function s(){o.send_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(I)}function a(){clearInterval(i),i=setInterval(s,e)}if(!1===n.has(o)){let e,t;n.set(o,{[Symbol.asyncIterator]:o[Symbol.asyncIterator].bind(o),send_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:(...e)=>(a(),o.send_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(...e))}),(async()=>{try{for await(const e of o)a()}catch{}finally{n.delete(o),clearInterval(i),e&&globalThis.window.removeEventListener("offline",e),t&&globalThis.window.removeEventListener("online",t)}})(),globalThis.navigator.onLine&&a(),e=()=>{clearInterval(i)},t=()=>{s(),a()},globalThis.window.addEventListener("offline",e),globalThis.window.addEventListener("online",t)}return n.get(o)}}({intervalMs:n??5e3,transport:e})),(e=>function({getShard:e,transport:t}){return x({getAbortSignalFromInputArgs:({signal:e})=>e,getCacheEntryMissingError:e=>new Error(`Found no cache entry for connection with shard key \`${e?.toString()}\``),getCacheKeyFromInputArgs:({payload:t})=>e?e(t):T,onCacheHit:(e,{payload:t})=>e.send_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(t),onCreateIterable:(e,n)=>t({...n,signal:e})})}({getShard:t,transport:e})))},t.createDefaultRpcTransport=function(e){return c.pipe(u.createHttpTransport({...e,headers:{...e.headers?z(e.headers):void 0,"solana-client":"js/2.0.0-development"}}),(e=>function(e,t){let n;return async function(r){const{payload:o,signal:i}=r,s=t(o);if(void 0===s)return await e(r);if(n||(Promise.resolve().then((()=>{n=void 0})),n={}),null==n[s]){const t=new AbortController;n[s]={abortController:t,numConsumers:0,responsePromise:e({...r,signal:t.signal})}}const a=n[s];if(a.numConsumers++,i){const e=a.responsePromise;return await new Promise(((t,n)=>{const r=e=>{i.removeEventListener("abort",r),a.numConsumers-=1,0===a.numConsumers&&a.abortController.abort();const t=new DOMException(e.target.reason,"AbortError");n(t)};i.addEventListener("abort",r),e.then(t).finally((()=>{i.removeEventListener("abort",r)}))}))}return await a.responsePromise}}(e,A)))},t.createDefaultTransactionSender=function({rpc:e,rpcSubscriptions:t}){const n=N({rpc:e,rpcSubscriptions:t});return async function(t,r){await P({...r,confirmRecentTransaction:n,rpc:e,transaction:t})}},t.createNonceInvalidationPromiseFactory=B,t.createRecentSignatureConfirmationPromiseFactory=y,t.createSolanaRpc=function(e){return u.createJsonRpc({...e,api:d.createSolanaRpcApi(E)})},t.createSolanaRpcSubscriptions=function(e){return c.pipe(u.createJsonSubscriptionRpc({...e,api:d.createSolanaRpcSubscriptionsApi(E)}),(e=>function({getDeduplicationKey:e,rpcSubscriptions:t}){const n=new Map;return new Proxy(t,{defineProperty:()=>!1,deleteProperty:()=>!1,get(t,r,o){const i=Reflect.get(t,r,o);return"function"!=typeof i?i:function(...t){const o=e(r,t);if(void 0===o)return i(...t);if(n.has(o))return n.get(o);const s=x({getAbortSignalFromInputArgs:({abortSignal:e})=>e,getCacheEntryMissingError:e=>new Error(`Found no cache entry for subscription with deduplication key \`${e?.toString()}\``),getCacheKeyFromInputArgs:()=>o,async onCacheHit(e,t){},async onCreateIterable(e,r){const s=i(...t),a=await s.subscribe({...r,abortSignal:e});return function(e,t){(async()=>{try{for await(const t of e);}catch{}finally{n.delete(o)}})()}(a),a}}),a={async subscribe(...e){const t=await s(...e),{abortSignal:r}=e[0];let i;return{...t,async*[Symbol.asyncIterator](){i||(i=r.aborted?Promise.reject(v):new Promise(((e,t)=>{r.addEventListener("abort",(()=>{t(v)}))})));try{const e=t[Symbol.asyncIterator]();for(;;){const t=await Promise.race([e.next(),i]);if(t.done)return;yield t.value}}catch(e){if(e===v)return;throw n.delete(o),e}}}}};return n.set(o,a),a}}})}({getDeduplicationKey:(...e)=>p.default(e),rpcSubscriptions:e})))},t.createSolanaRpcSubscriptions_UNSTABLE=function(e){return u.createJsonSubscriptionRpc({...e,api:d.createSolanaRpcSubscriptionsApi_UNSTABLE(E)})},t.requestAndConfirmAirdrop=w,t.sendAndConfirmDurableNonceTransaction=L,t.sendAndConfirmTransaction=P,t.waitForDurableNonceTransactionConfirmation=U,t.waitForRecentTransactionConfirmation=R,Object.keys(r).forEach((function(e){"default"===e||Object.prototype.hasOwnProperty.call(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:function(){return r[e]}})})),Object.keys(o).forEach((function(e){"default"===e||Object.prototype.hasOwnProperty.call(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:function(){return o[e]}})})),Object.keys(i).forEach((function(e){"default"===e||Object.prototype.hasOwnProperty.call(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:function(){return i[e]}})})),Object.keys(s).forEach((function(e){"default"===e||Object.prototype.hasOwnProperty.call(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:function(){return s[e]}})})),Object.keys(a).forEach((function(e){"default"===e||Object.prototype.hasOwnProperty.call(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:function(){return a[e]}})}))},920:(e,t,n)=>{"use strict";var r=n(929);t.generateKeyPair=async function(){return await r.assertKeyGenerationIsAvailable(),await crypto.subtle.generateKey("Ed25519",!1,["sign","verify"])},t.signBytes=async function(e,t){await r.assertSigningCapabilityIsAvailable();const n=await crypto.subtle.sign("Ed25519",e,t);return new Uint8Array(n)},t.verifySignature=async function(e,t,n){return await r.assertVerificationCapabilityIsAvailable(),await crypto.subtle.verify("Ed25519",e,t,n)}},181:()=>{"use strict";var e=(()=>!1)(),t=2n**255n-19n,n=2n**252n+27742317777372353535851937790883648493n,r=0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51an,o=0x6666666666666666666666666666666666666666666666666666666666666658n,i={a:-1n,d:37095705934669439343138083508754565189542113879843219016388785533085940283555n,p:t,n,h:8,Gx:r,Gy:o},s=(e="")=>{throw new Error(e)},a=e=>"string"==typeof e,c=(e,t)=>!(e instanceof Uint8Array)||"number"==typeof t&&t>0&&e.length!==t?s("Uint8Array expected"):e,d=e=>new Uint8Array(e),u=(e,t)=>c(a(e)?S(e):d(e),t),l=(e,n=t)=>{let r=e%n;return r>=0n?r:n+r},f=e=>e instanceof p?e:s("Point expected"),g=void 0,p=class e{constructor(e,t,n,r){this.ex=e,this.ey=t,this.ez=n,this.et=r}static fromAffine(t){return new e(t.x,t.y,1n,l(t.x*t.y))}static fromHex(n,r=!0){const{d:o}=i,a=(n=u(n,32)).slice();a[31]=-129&n[31];const c=x(a);0n===c||(!r||0n<c&&c<t||s("bad y coord 1"),r||0n<c&&c<2n**256n||s("bad y coord 2"));const d=l(c*c),f=l(d-1n),g=l(o*d+1n);let{isValid:p,value:m}=T(f,g);p||s("bad y coordinate 3");const h=1n===(1n&m);return 0!=(128&n[31])!==h&&(m=l(-m)),new e(m,c,1n,l(m*c))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}equals(e){const{ex:t,ey:n,ez:r}=this,{ex:o,ey:i,ez:s}=f(e),a=l(t*s),c=l(o*r),d=l(n*s),u=l(i*r);return a===c&&d===u}is0(){return this.equals(y)}negate(){return new e(l(-this.ex),this.ey,this.ez,l(-this.et))}double(){const{ex:t,ey:n,ez:r}=this,{a:o}=i,s=l(t*t),a=l(n*n),c=l(2n*l(r*r)),d=l(o*s),u=t+n,f=l(l(u*u)-s-a),g=d+a,p=g-c,m=d-a,h=l(f*p),y=l(g*m),b=l(f*m),w=l(p*g);return new e(h,y,w,b)}add(t){const{ex:n,ey:r,ez:o,et:s}=this,{ex:a,ey:c,ez:d,et:u}=f(t),{a:g,d:p}=i,m=l(n*a),h=l(r*c),y=l(s*p*u),b=l(o*d),w=l((n+r)*(a+c)-m-h),S=l(b-y),E=l(b+y),x=l(h-g*m),v=l(w*S),A=l(E*x),z=l(w*x),I=l(S*E);return new e(v,A,I,z)}mul(e,t=!0){if(0n===e)return!0===t?s("cannot multiply by 0"):y;if("bigint"==typeof e&&0n<e&&e<n||s("invalid scalar, must be < L"),!t&&this.is0()||1n===e)return this;if(this.equals(h))return _(e).p;let r=y,o=h;for(let n=this;e>0n;n=n.double(),e>>=1n)1n&e?r=r.add(n):t&&(o=o.add(n));return r}multiply(e){return this.mul(e)}clearCofactor(){return this.mul(BigInt(i.h),!1)}isSmallOrder(){return this.clearCofactor().is0()}isTorsionFree(){let e=this.mul(n/2n,!1).double();return n%2n&&(e=e.add(this)),e.is0()}toAffine(){const{ex:e,ey:t,ez:n}=this;if(this.is0())return{x:0n,y:0n};const r=A(n);return 1n!==l(n*r)&&s("invalid inverse"),{x:l(e*r),y:l(t*r)}}toRawBytes(){const{x:e,y:t}=this.toAffine(),n=E(t);return n[31]|=1n&e?128:0,n}toHex(){return w(this.toRawBytes())}};p.BASE=new p(r,o,1n,l(r*o)),p.ZERO=new p(0n,1n,1n,0n);var m,{BASE:h,ZERO:y}=p,b=(e,t)=>e.toString(16).padStart(t,"0"),w=e=>Array.from(e).map((e=>b(e,2))).join(""),S=e=>{const t=e.length;(!a(e)||t%2)&&s("hex invalid 1");const n=d(t/2);for(let t=0;t<n.length;t++){const r=2*t,o=e.slice(r,r+2),i=Number.parseInt(o,16);(Number.isNaN(i)||i<0)&&s("hex invalid 2"),n[t]=i}return n},E=e=>S(b(e,64)).reverse(),x=e=>BigInt("0x"+w(d(c(e)).reverse())),v=(...e)=>{const t=d(e.reduce(((e,t)=>e+c(t).length),0));let n=0;return e.forEach((e=>{t.set(e,n),n+=e.length})),t},A=(e,n=t)=>{(0n===e||n<=0n)&&s("no inverse n="+e+" mod="+n);let r=l(e,n),o=n,i=0n,a=1n;for(;0n!==r;){const e=o%r,t=i-a*(o/r);o=r,r=e,i=a,a=t}return 1n===o?l(i,n):s("no inverse")},z=(e,n)=>{let r=e;for(;n-- >0n;)r*=r,r%=t;return r},I=19681161376707505956807079304988542015446066515923890162744021073123829784752n,T=(e,n)=>{const r=l(n*n*n),o=(e=>{const n=e*e%t*e%t,r=z(n,2n)*n%t,o=z(r,1n)*e%t,i=z(o,5n)*o%t,s=z(i,10n)*i%t,a=z(s,20n)*s%t,c=z(a,40n)*a%t,d=z(c,80n)*c%t,u=z(d,80n)*c%t,l=z(u,10n)*i%t;return{pow_p_5_8:z(l,2n)*e%t,b2:n}})(e*l(r*r*n)).pow_p_5_8;let i=l(e*r*o);const s=l(n*i*i),a=i,c=l(i*I),d=s===e,u=s===l(-e),f=s===l(-e*I);return d&&(i=a),(u||f)&&(i=c),1n===(1n&l(i))&&(i=l(-i)),{isValid:d||u,value:i}},C=e=>l(x(e),n),k=(...e)=>O.sha512Async(...e),B=(...e)=>"function"==typeof m?m(...e):s("etc.sha512Sync not set"),D=e=>{const t=e.slice(0,32);t[0]&=248,t[31]&=127,t[31]|=64;const n=e.slice(32,64),r=C(t),o=h.mul(r),i=o.toRawBytes();return{head:t,prefix:n,scalar:r,point:o,pointBytes:i}},N=e=>k(u(e,32)).then(D);function U(e,t){return e?k(t.hashable).then(t.finish):t.finish(B(t.hashable))}var R=()=>"object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0,O={bytesToHex:w,hexToBytes:S,concatBytes:v,mod:l,invert:A,randomBytes:e=>{const t=R();return t||s("crypto.getRandomValues must be defined"),t.getRandomValues(d(e))},sha512Async:async(...e)=>{const t=R();t||s("crypto.subtle or etc.sha512Async must be defined");const n=v(...e);return d(await t.subtle.digest("SHA-512",n.buffer))},sha512Sync:void 0};Object.defineProperties(O,{sha512Sync:{configurable:!1,get:()=>m,set(e){m||(m=e)}}});var $,L,P=()=>O.randomBytes(32),_=e=>{const t=g||(g=(()=>{const e=[];let t=h,n=t;for(let r=0;r<33;r++){n=t,e.push(n);for(let r=1;r<128;r++)n=n.add(t),e.push(n);t=n.double()}return e})()),n=(e,t)=>{let n=t.negate();return e?n:t};let r=y,o=h;const i=BigInt(255),s=BigInt(8);for(let a=0;a<33;a++){const c=128*a;let d=Number(e&i);e>>=s,d>128&&(d-=256,e+=1n);const u=c,l=c+Math.abs(d)-1,f=a%2!=0,g=d<0;0===d?o=o.add(n(f,t[u])):r=r.add(n(g,t[l]))}return{p:r,f:o}},j=new Set(["decrypt","deriveBits","deriveKey","encrypt","unwrapKey","wrapKey"]),F=[48,46,2,1,0,48,5,6,3,43,101,112,4,34,4,32];function M(e){return e instanceof Uint8Array?e:new Uint8Array(ArrayBuffer.isView(e)?e.buffer:e)}function K(e){const t=$?.get(e);if(void 0===t)throw new Error("Could not find secret key material associated with this `CryptoKey`");return t}async function W(e){const t=L||=new WeakMap,n=t.get(e);if(n)return n;const r=await(o=K(e),N(o).then((e=>e.pointBytes)));var o;return t.set(e,r),r}function H(e){return!!$?.has(e)||!!L?.has(e)}if(globalThis.isSecureContext){const t=globalThis.crypto||={},r=t.subtle||={},o=r.exportKey;r.exportKey=async(...e)=>{const[t,n]=e;if(H(n))return await async function(e,t){if(!1===t.extractable)throw new DOMException("key is not extractable","InvalidAccessException");switch(e){case"raw":if("public"!==t.type)throw new DOMException(`Unable to export a raw Ed25519 ${t.type} key`,"InvalidAccessError");return await W(t);case"pkcs8":{if("private"!==t.type)throw new DOMException(`Unable to export a pkcs8 Ed25519 ${t.type} key`,"InvalidAccessError");const e=K(t);return new Uint8Array([...F,...e])}default:throw new Error(`Exporting polyfilled Ed25519 keys in the "${e}" format is unimplemented`)}}(...e);if(o)return await o.apply(r,e);throw new TypeError("No native `exportKey` function exists to handle this call")};const i=r.generateKey;let s;r.generateKey=async(...t)=>{const[n]=t;if("Ed25519"!==n){if(i)return await i.apply(r,t);throw new TypeError("No native `generateKey` function exists to handle this call")}let o;if(void 0===s&&(s=new Promise((n=>{i?i.apply(r,t).then((t=>{e&&console.warn("`@solana/webcrypto-ed25519-polyfill` was included in an environment that supports Ed25519 key manipulation natively. Falling back to the native implementation. Consider including this polyfill only in environments where Ed25519 is not supported."),r.generateKey!==i&&(r.generateKey=i),o=t,n(s=!0)})).catch((()=>{n(s=!1)})):n(s=!1)}))),"boolean"==typeof s?s:await s){if(o)return o;if(i)return await i.apply(r,t);throw new TypeError("No native `generateKey` function exists to handle this call")}{const[e,n,r]=t;return function(e,t){return function(e,t,n){const r=function(e,t){if(0===t.length)throw new DOMException("Usages cannot be empty when creating a key.","SyntaxError");if(t.some((e=>j.has(e))))throw new DOMException("Unsupported key usage for an Ed25519 key.","SyntaxError");const n={[Symbol.toStringTag]:"CryptoKey",algorithm:Object.freeze({name:"Ed25519"})},r={...n,extractable:e,type:"private",usages:Object.freeze(t.filter((e=>"sign"===e)))},o={...n,extractable:!0,type:"public",usages:Object.freeze(t.filter((e=>"verify"===e)))};return Object.freeze({privateKey:Object.freeze(r),publicKey:Object.freeze(o)})}(t,n),o=$||=new WeakMap;return o.set(r.privateKey,e),o.set(r.publicKey,e),r}(P(),e,t)}(n,r)}};const a=r.sign;r.sign=async(...e)=>{const[t,o]=e;if(H(o)){const[t,...r]=e;return await async function(e,t){if("private"!==e.type||!e.usages.includes("sign"))throw new DOMException("Unable to use this key to sign","InvalidAccessError");const r=K(e),o=M(t);return await(async(e,t)=>{const r=u(e),o=await N(t);return U(!0,((e,t,r)=>{const{pointBytes:o,scalar:i}=e,s=C(t),a=h.mul(s).toRawBytes();return{hashable:v(a,o,r),finish:e=>{const t=l(s+C(e)*i,n);return c(v(a,E(t)),64)}}})(o,await k(o.prefix,r),r))})(o,r)}(...r)}if(a)return await a.apply(r,e);throw new TypeError("No native `sign` function exists to handle this call")};const d=r.verify;r.verify=async(...e)=>{const[t,n]=e;if(H(n)){const[t,...n]=e;return await async function(e,t,n){if("public"!==e.type||!e.usages.includes("verify"))throw new DOMException("Unable to use this key to verify","InvalidAccessError");const r=await W(e);try{return await(async(e,t,n)=>U(!0,((e,t,n)=>{t=u(t),e=u(e,64);const r=p.fromHex(n,!1),o=p.fromHex(e.slice(0,32),!1),i=x(e.slice(32,64)),s=h.mul(i,!1);return{hashable:v(o.toRawBytes(),r.toRawBytes(),t),finish:e=>{const t=C(e);return o.add(r.mul(t,!1)).add(s.negate()).clearCofactor().is0()}}})(e,t,n)))(M(t),M(n),r)}catch{return!1}}(...n)}if(d)return await d.apply(r,e);throw new TypeError("No native `verify` function exists to handle this call")};const f=r.importKey;let g;r.importKey=async(...t)=>{const[n,o,i]=t;if("Ed25519"!==i){if(f)return await f.apply(r,t);throw new TypeError("No native `importKey` function exists to handle this call")}let s;if(void 0===g&&(g=new Promise((n=>{f?f.apply(r,t).then((t=>{e&&console.warn("`@solana/webcrypto-ed25519-polyfill` was included in an environment that supports Ed25519 key manipulation natively. Falling back to the native implementation. Consider including this polyfill only in environments where Ed25519 is not supported."),r.importKey!==f&&(r.importKey=f),s=t,n(g=!0)})).catch((()=>{n(g=!1)})):n(g=!1)}))),"boolean"==typeof f?g:await g){if(s)return s;if(f)return await f.apply(r,t);throw new TypeError("No native `importKey` function exists to handle this call")}{const[e,r,i,s,a]=t;return function(e,t,n,r){const o=M(t);if("raw"===e){if(r.some((e=>"sign"===e||j.has(e))))throw new DOMException("Unsupported key usage for a Ed25519 key","SyntaxError");if(32!==o.length)throw new DOMException("Ed25519 raw keys must be exactly 32-bytes","DataError");const e={[Symbol.toStringTag]:"CryptoKey",algorithm:Object.freeze({name:"Ed25519"}),extractable:n,type:"public",usages:Object.freeze(r.filter((e=>"verify"===e)))};return(L||=new WeakMap).set(e,o),e}if("pkcs8"===e){if(r.some((e=>"verify"===e||j.has(e))))throw new DOMException("Unsupported key usage for a Ed25519 key","SyntaxError");if(48!==o.length)throw new DOMException("Invalid keyData","DataError");if(!o.slice(0,16).every(((e,t)=>e===F[t])))throw new DOMException("Invalid keyData","DataError");const e=o.slice(16),t={[Symbol.toStringTag]:"CryptoKey",algorithm:Object.freeze({name:"Ed25519"}),extractable:n,type:"private",usages:Object.freeze(r.filter((e=>"sign"===e)))};return($||=new WeakMap).set(t,e),t}throw new Error(`Importing Ed25519 keys in the "${e}" format is unimplemented`)}(n,o,s,a)}}}}},t={};!function n(r){var o=t[r];if(void 0!==o)return o.exports;var i=t[r]={exports:{}};return e[r].call(i.exports,i,i.exports,n),i.exports}(827)})();